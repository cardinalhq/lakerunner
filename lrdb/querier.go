// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package lrdb

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type Querier interface {
	BatchDeleteMetricSegs(ctx context.Context, arg []BatchDeleteMetricSegsParams) *BatchDeleteMetricSegsBatchResults
	BatchInsertMetricSegs(ctx context.Context, arg []BatchInsertMetricSegsParams) *BatchInsertMetricSegsBatchResults
	BatchMarkMetricSegsRolledup(ctx context.Context, arg []BatchMarkMetricSegsRolledupParams) *BatchMarkMetricSegsRolledupBatchResults
	// This will upsert a new log exemplar. Attributes, exemplar, and updated_at are always updated
	// to the provided values. If old_fingerprint is not 0, it is added to the list of related
	// fingerprints. This means the "old" fingerprint should be fingerprint, so it always updates
	// an existing record, not changing it to the new one.
	// The return value is a boolean indicating if the record is new.
	BatchUpsertExemplarLogs(ctx context.Context, arg []BatchUpsertExemplarLogsParams) *BatchUpsertExemplarLogsBatchResults
	BatchUpsertExemplarMetrics(ctx context.Context, arg []BatchUpsertExemplarMetricsParams) *BatchUpsertExemplarMetricsBatchResults
	BatchUpsertExemplarTraces(ctx context.Context, arg []BatchUpsertExemplarTracesParams) *BatchUpsertExemplarTracesBatchResults
	// 1) Safety net: if any single file already meets/exceeds the cap, take that file alone
	// 2) One seed (oldest/highest-priority) per group (org, instance) within signal
	// 3) Order groups globally by their seed (priority DESC, queue_ts ASC)
	// 4) Attach age flags + caps per group (using params only; no per-row estimator here)
	// 5) All ready rows in each group for that signal (selection only; claim happens later)
	// 6) Greedy pack within each group, ordered by priority/queue_ts
	// 7) Keep only rows that fit under caps
	// 8) Totals per group (what weâ€™d actually claim)
	// 9) Eligibility:
	//    fresh: require total_size >= min_total_size (exactness not required for raw files)
	//    old:   any positive amount (already capped by max_total_size)
	// 10) Pick earliest eligible group globally
	// 11) Rows to claim for the winner group
	// 12) Final chosen IDs: prefer big_single if present; else packed group rows
	// 13) Atomic optimistic claim (no window funcs here)
	ClaimInqueueWorkBatch(ctx context.Context, arg ClaimInqueueWorkBatchParams) ([]ClaimInqueueWorkBatchRow, error)
	// 1) Big single-row safety net
	// 2) One seed per group (org, dateint, freq, instance)
	// 3) Order groups globally by seed recency/priority
	// 4) Attach per-group target_records
	// 5) All ready rows within each group
	// 6) Greedy pack per group
	// 7) Rows that fit under caps
	// 8) Totals per group
	// 9) Eligibility: fresh = exact fill, old = any positive
	// 10) Pick earliest eligible group
	// 11) Rows to claim for the winner group
	// 12) Final chosen IDs
	// 13) Atomic optimistic claim
	ClaimMetricCompactionWork(ctx context.Context, arg ClaimMetricCompactionWorkParams) ([]ClaimMetricCompactionWorkRow, error)
	CleanupInqueueWork(ctx context.Context, cutoffTime *time.Time) ([]Inqueue, error)
	CleanupMetricCompactionWork(ctx context.Context, cutoffTime *time.Time) ([]MetricCompactionQueue, error)
	CompactLogSegments(ctx context.Context, arg CompactLogSegmentsParams) error
	CompactTraceSegments(ctx context.Context, arg CompactTraceSegmentsParams) error
	DeleteInqueueWork(ctx context.Context, arg DeleteInqueueWorkParams) error
	DeleteMetricCompactionWork(ctx context.Context, arg DeleteMetricCompactionWorkParams) error
	GetExemplarLogsByFingerprint(ctx context.Context, arg GetExemplarLogsByFingerprintParams) (ExemplarLog, error)
	GetExemplarLogsByService(ctx context.Context, arg GetExemplarLogsByServiceParams) ([]ExemplarLog, error)
	GetExemplarLogsCreatedAfter(ctx context.Context, ts time.Time) ([]ExemplarLog, error)
	GetExemplarMetricsByService(ctx context.Context, arg GetExemplarMetricsByServiceParams) ([]ExemplarMetric, error)
	GetExemplarMetricsCreatedAfter(ctx context.Context, ts time.Time) ([]ExemplarMetric, error)
	GetExemplarTracesByFingerprint(ctx context.Context, arg GetExemplarTracesByFingerprintParams) (ExemplarTrace, error)
	GetExemplarTracesByService(ctx context.Context, arg GetExemplarTracesByServiceParams) ([]ExemplarTrace, error)
	GetExemplarTracesCreatedAfter(ctx context.Context, ts time.Time) ([]ExemplarTrace, error)
	GetLogSegmentsForCompaction(ctx context.Context, arg GetLogSegmentsForCompactionParams) ([]GetLogSegmentsForCompactionRow, error)
	GetMetricSegsForCompaction(ctx context.Context, arg GetMetricSegsForCompactionParams) ([]MetricSeg, error)
	GetMetricSegsForCompactionWork(ctx context.Context, arg GetMetricSegsForCompactionWorkParams) ([]MetricSeg, error)
	GetMetricSegsForRollup(ctx context.Context, arg GetMetricSegsForRollupParams) ([]MetricSeg, error)
	GetSpanInfoByFingerprint(ctx context.Context, arg GetSpanInfoByFingerprintParams) (GetSpanInfoByFingerprintRow, error)
	GetTraceSegmentsForCompaction(ctx context.Context, arg GetTraceSegmentsForCompactionParams) ([]GetTraceSegmentsForCompactionRow, error)
	InqueueJournalDelete(ctx context.Context, arg InqueueJournalDeleteParams) error
	InqueueJournalUpsert(ctx context.Context, arg InqueueJournalUpsertParams) (bool, error)
	InqueueSummary(ctx context.Context) ([]InqueueSummaryRow, error)
	InsertCompactedMetricSeg(ctx context.Context, arg []InsertCompactedMetricSegParams) *InsertCompactedMetricSegBatchResults
	InsertLogSegmentDirect(ctx context.Context, arg InsertLogSegmentParams) error
	InsertMetricSegmentDirect(ctx context.Context, arg InsertMetricSegmentParams) error
	InsertTraceSegmentDirect(ctx context.Context, arg InsertTraceSegmentDirectParams) error
	ListLogSegmentsForQuery(ctx context.Context, arg ListLogSegmentsForQueryParams) ([]ListLogSegmentsForQueryRow, error)
	ListMetricSegmentsForQuery(ctx context.Context, arg ListMetricSegmentsForQueryParams) ([]ListMetricSegmentsForQueryRow, error)
	// Returns an estimate of the number of log segments, average bytes, average records,
	// and average bytes per record for log segments in the last hour per organization and instance.
	// This query is basically identical to the MetricSegEstimator, but for log segments.
	LogSegEstimator(ctx context.Context, arg LogSegEstimatorParams) ([]LogSegEstimatorRow, error)
	MarkMetricSegsCompactedByKeys(ctx context.Context, arg MarkMetricSegsCompactedByKeysParams) error
	// Returns an estimate of the number of metric segments, average bytes, average records,
	// and average bytes per record for metric segments in the last hour per organization, instance, and frequency.
	// Uses frequency_ms to provide more accurate estimates based on collection frequency.
	MetricSegEstimator(ctx context.Context, arg MetricSegEstimatorParams) ([]MetricSegEstimatorRow, error)
	ObjectCleanupAdd(ctx context.Context, arg ObjectCleanupAddParams) error
	ObjectCleanupBucketSummary(ctx context.Context) ([]ObjectCleanupBucketSummaryRow, error)
	ObjectCleanupComplete(ctx context.Context, id uuid.UUID) error
	ObjectCleanupFail(ctx context.Context, id uuid.UUID) error
	ObjectCleanupGet(ctx context.Context, maxrows int32) ([]ObjectCleanupGetRow, error)
	PutInqueueWork(ctx context.Context, arg PutInqueueWorkParams) error
	PutMetricCompactionWork(ctx context.Context, arg PutMetricCompactionWorkParams) error
	ReleaseInqueueWork(ctx context.Context, arg ReleaseInqueueWorkParams) error
	ReleaseMetricCompactionWork(ctx context.Context, arg ReleaseMetricCompactionWorkParams) error
	SignalLockCleanup(ctx context.Context) (int32, error)
	TouchInqueueWork(ctx context.Context, arg TouchInqueueWorkParams) error
	TouchMetricCompactionWork(ctx context.Context, arg TouchMetricCompactionWorkParams) error
	// Returns an estimate of the number of trace segments, average bytes, average records,
	// and average bytes per record for trace segments in the last hour per organization and instance.
	// This query is basically identical to the LogSegEstimator, but for trace segments.
	TraceSegEstimator(ctx context.Context, arg TraceSegEstimatorParams) ([]TraceSegEstimatorRow, error)
	UpsertServiceIdentifier(ctx context.Context, arg UpsertServiceIdentifierParams) (UpsertServiceIdentifierRow, error)
	WorkQueueAddDirect(ctx context.Context, arg WorkQueueAddParams) error
	WorkQueueClaimDirect(ctx context.Context, arg WorkQueueClaimParams) (WorkQueueClaimRow, error)
	WorkQueueCleanupDirect(ctx context.Context, lockTtlDead pgtype.Interval) ([]WorkQueueCleanupRow, error)
	WorkQueueCompleteDirect(ctx context.Context, arg WorkQueueCompleteParams) error
	WorkQueueDeleteDirect(ctx context.Context, arg WorkQueueDeleteParams) error
	// First, return unclaimed summaries
	// Then, return claimed details
	WorkQueueExtendedStatus(ctx context.Context) ([]WorkQueueExtendedStatusRow, error)
	WorkQueueFailDirect(ctx context.Context, arg WorkQueueFailParams) error
	WorkQueueGC(ctx context.Context, arg WorkQueueGCParams) (int32, error)
	WorkQueueGlobalLock(ctx context.Context) error
	// 1) heart-beat the work_queue
	WorkQueueHeartbeatDirect(ctx context.Context, arg WorkQueueHeartbeatParams) error
	WorkQueueOrphanedSignalLockCleanup(ctx context.Context, maxrows int32) (int32, error)
	WorkQueueSummary(ctx context.Context) ([]WorkQueueSummaryRow, error)
}

var _ Querier = (*Queries)(nil)
