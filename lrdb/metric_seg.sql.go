// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: metric_seg.sql

package lrdb

import (
	"context"

	"github.com/google/uuid"
)

const getMetricLabelNameMaps = `-- name: GetMetricLabelNameMaps :many
SELECT
    segment_id,
    label_name_map
FROM metric_seg
WHERE organization_id = $1
  AND dateint = $2
  AND frequency_ms = $3
  AND segment_id = ANY($4::BIGINT[])
  AND label_name_map IS NOT NULL
`

type GetMetricLabelNameMapsParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	FrequencyMs    int32     `json:"frequency_ms"`
	SegmentIds     []int64   `json:"segment_ids"`
}

type GetMetricLabelNameMapsRow struct {
	SegmentID    int64  `json:"segment_id"`
	LabelNameMap []byte `json:"label_name_map"`
}

func (q *Queries) GetMetricLabelNameMaps(ctx context.Context, arg GetMetricLabelNameMapsParams) ([]GetMetricLabelNameMapsRow, error) {
	rows, err := q.db.Query(ctx, getMetricLabelNameMaps,
		arg.OrganizationID,
		arg.Dateint,
		arg.FrequencyMs,
		arg.SegmentIds,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMetricLabelNameMapsRow
	for rows.Next() {
		var i GetMetricLabelNameMapsRow
		if err := rows.Scan(&i.SegmentID, &i.LabelNameMap); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMetricSeg = `-- name: GetMetricSeg :one
SELECT organization_id, dateint, frequency_ms, segment_id, instance_num, ts_range, record_count, file_size, ingest_dateint, published, rolledup, created_at, created_by, fingerprints, sort_version, compacted, label_name_map, metric_names
FROM metric_seg
WHERE organization_id = $1
  AND dateint = $2
  AND frequency_ms = $3
  AND segment_id = $4
  AND instance_num = $5
`

type GetMetricSegParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	FrequencyMs    int32     `json:"frequency_ms"`
	SegmentID      int64     `json:"segment_id"`
	InstanceNum    int16     `json:"instance_num"`
}

func (q *Queries) GetMetricSeg(ctx context.Context, arg GetMetricSegParams) (MetricSeg, error) {
	row := q.db.QueryRow(ctx, getMetricSeg,
		arg.OrganizationID,
		arg.Dateint,
		arg.FrequencyMs,
		arg.SegmentID,
		arg.InstanceNum,
	)
	var i MetricSeg
	err := row.Scan(
		&i.OrganizationID,
		&i.Dateint,
		&i.FrequencyMs,
		&i.SegmentID,
		&i.InstanceNum,
		&i.TsRange,
		&i.RecordCount,
		&i.FileSize,
		&i.IngestDateint,
		&i.Published,
		&i.Rolledup,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.Fingerprints,
		&i.SortVersion,
		&i.Compacted,
		&i.LabelNameMap,
		&i.MetricNames,
	)
	return i, err
}

const getMetricSegsByIds = `-- name: GetMetricSegsByIds :many
SELECT organization_id, dateint, frequency_ms, segment_id, instance_num, ts_range, record_count, file_size, ingest_dateint, published, rolledup, created_at, created_by, fingerprints, sort_version, compacted, label_name_map, metric_names
FROM metric_seg
WHERE organization_id = $1
  AND dateint = $2
  AND frequency_ms = $3
  AND instance_num = $4
  AND segment_id = ANY($5::bigint[])
ORDER BY segment_id
`

type GetMetricSegsByIdsParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	FrequencyMs    int32     `json:"frequency_ms"`
	InstanceNum    int16     `json:"instance_num"`
	SegmentIds     []int64   `json:"segment_ids"`
}

func (q *Queries) GetMetricSegsByIds(ctx context.Context, arg GetMetricSegsByIdsParams) ([]MetricSeg, error) {
	rows, err := q.db.Query(ctx, getMetricSegsByIds,
		arg.OrganizationID,
		arg.Dateint,
		arg.FrequencyMs,
		arg.InstanceNum,
		arg.SegmentIds,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MetricSeg
	for rows.Next() {
		var i MetricSeg
		if err := rows.Scan(
			&i.OrganizationID,
			&i.Dateint,
			&i.FrequencyMs,
			&i.SegmentID,
			&i.InstanceNum,
			&i.TsRange,
			&i.RecordCount,
			&i.FileSize,
			&i.IngestDateint,
			&i.Published,
			&i.Rolledup,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.Fingerprints,
			&i.SortVersion,
			&i.Compacted,
			&i.LabelNameMap,
			&i.MetricNames,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMetricNames = `-- name: ListMetricNames :many
SELECT DISTINCT
    unnest(metric_names)::text AS metric_name
FROM metric_seg
WHERE organization_id = $1
  AND dateint >= $2
  AND dateint <= $3
  AND ts_range && int8range($4, $5, '[)')
  AND published = true
  AND metric_names IS NOT NULL
`

type ListMetricNamesParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	StartDateint   int32     `json:"start_dateint"`
	EndDateint     int32     `json:"end_dateint"`
	StartTs        int64     `json:"start_ts"`
	EndTs          int64     `json:"end_ts"`
}

// Returns distinct metric names for an organization within a time range
func (q *Queries) ListMetricNames(ctx context.Context, arg ListMetricNamesParams) ([]string, error) {
	rows, err := q.db.Query(ctx, listMetricNames,
		arg.OrganizationID,
		arg.StartDateint,
		arg.EndDateint,
		arg.StartTs,
		arg.EndTs,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var metric_name string
		if err := rows.Scan(&metric_name); err != nil {
			return nil, err
		}
		items = append(items, metric_name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMetricSegmentsForQuery = `-- name: ListMetricSegmentsForQuery :many
SELECT
    instance_num,
    segment_id,
    lower(ts_range)::bigint AS start_ts,
    (upper(ts_range) - 1)::bigint AS end_ts
FROM metric_seg
WHERE ts_range && int8range($1, $2, '[)')
  AND dateint = $3
  AND frequency_ms = $4
  AND organization_id = $5
  AND fingerprints && $6::BIGINT[]
  AND published = true
`

type ListMetricSegmentsForQueryParams struct {
	StartTs        int64     `json:"start_ts"`
	EndTs          int64     `json:"end_ts"`
	Dateint        int32     `json:"dateint"`
	FrequencyMs    int32     `json:"frequency_ms"`
	OrganizationID uuid.UUID `json:"organization_id"`
	Fingerprints   []int64   `json:"fingerprints"`
}

type ListMetricSegmentsForQueryRow struct {
	InstanceNum int16 `json:"instance_num"`
	SegmentID   int64 `json:"segment_id"`
	StartTs     int64 `json:"start_ts"`
	EndTs       int64 `json:"end_ts"`
}

func (q *Queries) ListMetricSegmentsForQuery(ctx context.Context, arg ListMetricSegmentsForQueryParams) ([]ListMetricSegmentsForQueryRow, error) {
	rows, err := q.db.Query(ctx, listMetricSegmentsForQuery,
		arg.StartTs,
		arg.EndTs,
		arg.Dateint,
		arg.FrequencyMs,
		arg.OrganizationID,
		arg.Fingerprints,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMetricSegmentsForQueryRow
	for rows.Next() {
		var i ListMetricSegmentsForQueryRow
		if err := rows.Scan(
			&i.InstanceNum,
			&i.SegmentID,
			&i.StartTs,
			&i.EndTs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markMetricSegsCompactedByKeys = `-- name: MarkMetricSegsCompactedByKeys :exec
UPDATE metric_seg
SET compacted = true
WHERE organization_id = $1
  AND dateint         = $2
  AND frequency_ms    = $3
  AND instance_num    = $4
  AND segment_id      = ANY($5::bigint[])
  AND compacted       = false
`

type MarkMetricSegsCompactedByKeysParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	FrequencyMs    int32     `json:"frequency_ms"`
	InstanceNum    int16     `json:"instance_num"`
	SegmentIds     []int64   `json:"segment_ids"`
}

func (q *Queries) MarkMetricSegsCompactedByKeys(ctx context.Context, arg MarkMetricSegsCompactedByKeysParams) error {
	_, err := q.db.Exec(ctx, markMetricSegsCompactedByKeys,
		arg.OrganizationID,
		arg.Dateint,
		arg.FrequencyMs,
		arg.InstanceNum,
		arg.SegmentIds,
	)
	return err
}

const markMetricSegsRolledupByKeys = `-- name: MarkMetricSegsRolledupByKeys :exec
UPDATE metric_seg
SET rolledup = true
WHERE organization_id = $1
  AND dateint         = $2
  AND frequency_ms    = $3
  AND instance_num    = $4
  AND segment_id      = ANY($5::bigint[])
  AND rolledup        = false
`

type MarkMetricSegsRolledupByKeysParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	FrequencyMs    int32     `json:"frequency_ms"`
	InstanceNum    int16     `json:"instance_num"`
	SegmentIds     []int64   `json:"segment_ids"`
}

func (q *Queries) MarkMetricSegsRolledupByKeys(ctx context.Context, arg MarkMetricSegsRolledupByKeysParams) error {
	_, err := q.db.Exec(ctx, markMetricSegsRolledupByKeys,
		arg.OrganizationID,
		arg.Dateint,
		arg.FrequencyMs,
		arg.InstanceNum,
		arg.SegmentIds,
	)
	return err
}

const insertMetricSegDirect = `-- name: insertMetricSegDirect :exec
INSERT INTO metric_seg (
  organization_id,
  dateint,
  frequency_ms,
  segment_id,
  instance_num,
  ts_range,
  record_count,
  file_size,
  created_by,
  published,
  rolledup,
  fingerprints,
  sort_version,
  compacted,
  label_name_map,
  metric_names
)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  int8range($6, $7, '[)'),
  $8,
  $9,
  $10,
  $11,
  $12,
  $13::bigint[],
  $14,
  $15,
  $16,
  $17::text[]
)
`

type InsertMetricSegmentParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	FrequencyMs    int32     `json:"frequency_ms"`
	SegmentID      int64     `json:"segment_id"`
	InstanceNum    int16     `json:"instance_num"`
	StartTs        int64     `json:"start_ts"`
	EndTs          int64     `json:"end_ts"`
	RecordCount    int64     `json:"record_count"`
	FileSize       int64     `json:"file_size"`
	CreatedBy      CreatedBy `json:"created_by"`
	Published      bool      `json:"published"`
	Rolledup       bool      `json:"rolledup"`
	Fingerprints   []int64   `json:"fingerprints"`
	SortVersion    int16     `json:"sort_version"`
	Compacted      bool      `json:"compacted"`
	LabelNameMap   []byte    `json:"label_name_map"`
	MetricNames    []string  `json:"metric_names"`
}

func (q *Queries) insertMetricSegDirect(ctx context.Context, arg InsertMetricSegmentParams) error {
	_, err := q.db.Exec(ctx, insertMetricSegDirect,
		arg.OrganizationID,
		arg.Dateint,
		arg.FrequencyMs,
		arg.SegmentID,
		arg.InstanceNum,
		arg.StartTs,
		arg.EndTs,
		arg.RecordCount,
		arg.FileSize,
		arg.CreatedBy,
		arg.Published,
		arg.Rolledup,
		arg.Fingerprints,
		arg.SortVersion,
		arg.Compacted,
		arg.LabelNameMap,
		arg.MetricNames,
	)
	return err
}

const markMetricSegsCompactedUnpublishedByKeys = `-- name: markMetricSegsCompactedUnpublishedByKeys :exec
UPDATE metric_seg
SET compacted = true, published = false
WHERE organization_id = $1
  AND dateint         = $2
  AND frequency_ms    = $3
  AND instance_num    = $4
  AND segment_id      = ANY($5::bigint[])
  AND compacted       = false
`

type markMetricSegsCompactedUnpublishedByKeysParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	FrequencyMs    int32     `json:"frequency_ms"`
	InstanceNum    int16     `json:"instance_num"`
	SegmentIds     []int64   `json:"segment_ids"`
}

func (q *Queries) markMetricSegsCompactedUnpublishedByKeys(ctx context.Context, arg markMetricSegsCompactedUnpublishedByKeysParams) error {
	_, err := q.db.Exec(ctx, markMetricSegsCompactedUnpublishedByKeys,
		arg.OrganizationID,
		arg.Dateint,
		arg.FrequencyMs,
		arg.InstanceNum,
		arg.SegmentIds,
	)
	return err
}
