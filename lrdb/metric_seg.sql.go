// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: metric_seg.sql

package lrdb

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const getMetricSegsForCompaction = `-- name: GetMetricSegsForCompaction :many
SELECT organization_id, dateint, frequency_ms, segment_id, instance_num, tid_partition, ts_range, record_count, file_size, tid_count, ingest_dateint, published, rolledup, created_at, created_by, slot_id
FROM metric_seg
WHERE
  organization_id = $1 AND
  dateint = $2 AND
  frequency_ms = $3 AND
  instance_num = $4 AND
  ts_range && int8range($5, $6, '[)') AND
  file_size <= $7 AND
  (created_at, segment_id) > ($8, $9::bigint)
ORDER BY
  created_at, segment_id
LIMIT $10
`

type GetMetricSegsForCompactionParams struct {
	OrganizationID  uuid.UUID `json:"organization_id"`
	Dateint         int32     `json:"dateint"`
	FrequencyMs     int32     `json:"frequency_ms"`
	InstanceNum     int16     `json:"instance_num"`
	StartTs         int64     `json:"start_ts"`
	EndTs           int64     `json:"end_ts"`
	MaxFileSize     int64     `json:"max_file_size"`
	CursorCreatedAt time.Time `json:"cursor_created_at"`
	CursorSegmentID int64     `json:"cursor_segment_id"`
	Maxrows         int32     `json:"maxrows"`
}

func (q *Queries) GetMetricSegsForCompaction(ctx context.Context, arg GetMetricSegsForCompactionParams) ([]MetricSeg, error) {
	rows, err := q.db.Query(ctx, getMetricSegsForCompaction,
		arg.OrganizationID,
		arg.Dateint,
		arg.FrequencyMs,
		arg.InstanceNum,
		arg.StartTs,
		arg.EndTs,
		arg.MaxFileSize,
		arg.CursorCreatedAt,
		arg.CursorSegmentID,
		arg.Maxrows,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MetricSeg
	for rows.Next() {
		var i MetricSeg
		if err := rows.Scan(
			&i.OrganizationID,
			&i.Dateint,
			&i.FrequencyMs,
			&i.SegmentID,
			&i.InstanceNum,
			&i.TidPartition,
			&i.TsRange,
			&i.RecordCount,
			&i.FileSize,
			&i.TidCount,
			&i.IngestDateint,
			&i.Published,
			&i.Rolledup,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.SlotID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMetricSegsForRollup = `-- name: GetMetricSegsForRollup :many
SELECT organization_id, dateint, frequency_ms, segment_id, instance_num, tid_partition, ts_range, record_count, file_size, tid_count, ingest_dateint, published, rolledup, created_at, created_by, slot_id
FROM metric_seg
WHERE
  organization_id = $1 AND
  dateint = $2 AND
  frequency_ms = $3 AND
  instance_num = $4 AND
  slot_id = $5 AND
  ts_range && int8range($6, $7, '[)')
ORDER BY
  ts_range
`

type GetMetricSegsForRollupParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	FrequencyMs    int32     `json:"frequency_ms"`
	InstanceNum    int16     `json:"instance_num"`
	SlotID         int32     `json:"slot_id"`
	StartTs        int64     `json:"start_ts"`
	EndTs          int64     `json:"end_ts"`
}

func (q *Queries) GetMetricSegsForRollup(ctx context.Context, arg GetMetricSegsForRollupParams) ([]MetricSeg, error) {
	rows, err := q.db.Query(ctx, getMetricSegsForRollup,
		arg.OrganizationID,
		arg.Dateint,
		arg.FrequencyMs,
		arg.InstanceNum,
		arg.SlotID,
		arg.StartTs,
		arg.EndTs,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MetricSeg
	for rows.Next() {
		var i MetricSeg
		if err := rows.Scan(
			&i.OrganizationID,
			&i.Dateint,
			&i.FrequencyMs,
			&i.SegmentID,
			&i.InstanceNum,
			&i.TidPartition,
			&i.TsRange,
			&i.RecordCount,
			&i.FileSize,
			&i.TidCount,
			&i.IngestDateint,
			&i.Published,
			&i.Rolledup,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.SlotID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertMetricSegmentDirect = `-- name: InsertMetricSegmentDirect :exec
INSERT INTO metric_seg (
  organization_id,
  dateint,
  ingest_dateint,
  frequency_ms,
  segment_id,
  instance_num,
  slot_id,
  tid_partition,
  ts_range,
  record_count,
  file_size,
  tid_count,
  created_by,
  published
)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  int8range($9, $10, '[)'),
  $11,
  $12,
  $13,
  $14,
  $15
)
`

type InsertMetricSegmentParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	IngestDateint  int32     `json:"ingest_dateint"`
	FrequencyMs    int32     `json:"frequency_ms"`
	SegmentID      int64     `json:"segment_id"`
	InstanceNum    int16     `json:"instance_num"`
	SlotID         int32     `json:"slot_id"`
	TidPartition   int16     `json:"tid_partition"`
	StartTs        int64     `json:"start_ts"`
	EndTs          int64     `json:"end_ts"`
	RecordCount    int64     `json:"record_count"`
	FileSize       int64     `json:"file_size"`
	TidCount       int32     `json:"tid_count"`
	CreatedBy      CreatedBy `json:"created_by"`
	Published      bool      `json:"published"`
}

func (q *Queries) InsertMetricSegmentDirect(ctx context.Context, arg InsertMetricSegmentParams) error {
	_, err := q.db.Exec(ctx, insertMetricSegmentDirect,
		arg.OrganizationID,
		arg.Dateint,
		arg.IngestDateint,
		arg.FrequencyMs,
		arg.SegmentID,
		arg.InstanceNum,
		arg.SlotID,
		arg.TidPartition,
		arg.StartTs,
		arg.EndTs,
		arg.RecordCount,
		arg.FileSize,
		arg.TidCount,
		arg.CreatedBy,
		arg.Published,
	)
	return err
}

const listSegmentsForQuery = `-- name: ListSegmentsForQuery :many
SELECT
    instance_num,
    segment_id,
    lower(ts_range)::bigint AS start_ts,
    (upper(ts_range) - 1)::bigint AS end_ts
FROM metric_seg
WHERE ts_range && int8range($1, $2, '[)')
  AND dateint = $3
  AND frequency_ms = $4
  AND organization_id = $5
  AND published = true
`

type ListSegmentsForQueryParams struct {
	Int8range      int64     `json:"int8range"`
	Int8range_2    int64     `json:"int8range_2"`
	Dateint        int32     `json:"dateint"`
	FrequencyMs    int32     `json:"frequency_ms"`
	OrganizationID uuid.UUID `json:"organization_id"`
}

type ListSegmentsForQueryRow struct {
	InstanceNum int16 `json:"instance_num"`
	SegmentID   int64 `json:"segment_id"`
	StartTs     int64 `json:"start_ts"`
	EndTs       int64 `json:"end_ts"`
}

func (q *Queries) ListSegmentsForQuery(ctx context.Context, arg ListSegmentsForQueryParams) ([]ListSegmentsForQueryRow, error) {
	rows, err := q.db.Query(ctx, listSegmentsForQuery,
		arg.Int8range,
		arg.Int8range_2,
		arg.Dateint,
		arg.FrequencyMs,
		arg.OrganizationID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSegmentsForQueryRow
	for rows.Next() {
		var i ListSegmentsForQueryRow
		if err := rows.Scan(
			&i.InstanceNum,
			&i.SegmentID,
			&i.StartTs,
			&i.EndTs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
