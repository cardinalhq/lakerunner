// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: kafka_offset_journal.sql

package lrdb

import (
	"context"

	"github.com/google/uuid"
)

const kafkaGetLastProcessed = `-- name: KafkaGetLastProcessed :one
SELECT last_processed_offset
FROM kafka_offset_journal
WHERE consumer_group = $1
  AND topic = $2
  AND partition = $3
  AND organization_id = $4
  AND instance_num = $5
`

type KafkaGetLastProcessedParams struct {
	ConsumerGroup  string    `json:"consumer_group"`
	Topic          string    `json:"topic"`
	Partition      int32     `json:"partition"`
	OrganizationID uuid.UUID `json:"organization_id"`
	InstanceNum    int16     `json:"instance_num"`
}

// Get the last processed offset for a specific consumer group, topic, partition, organization, and instance
func (q *Queries) KafkaGetLastProcessed(ctx context.Context, arg KafkaGetLastProcessedParams) (int64, error) {
	row := q.db.QueryRow(ctx, kafkaGetLastProcessed,
		arg.ConsumerGroup,
		arg.Topic,
		arg.Partition,
		arg.OrganizationID,
		arg.InstanceNum,
	)
	var last_processed_offset int64
	err := row.Scan(&last_processed_offset)
	return last_processed_offset, err
}

const kafkaJournalGetLastProcessed = `-- name: KafkaJournalGetLastProcessed :one
SELECT last_processed_offset
FROM kafka_offset_journal
WHERE consumer_group = $1 AND topic = $2 AND partition = $3
`

type KafkaJournalGetLastProcessedParams struct {
	ConsumerGroup string `json:"consumer_group"`
	Topic         string `json:"topic"`
	Partition     int32  `json:"partition"`
}

// Get the last processed offset for a specific consumer group, topic, and partition
func (q *Queries) KafkaJournalGetLastProcessed(ctx context.Context, arg KafkaJournalGetLastProcessedParams) (int64, error) {
	row := q.db.QueryRow(ctx, kafkaJournalGetLastProcessed, arg.ConsumerGroup, arg.Topic, arg.Partition)
	var last_processed_offset int64
	err := row.Scan(&last_processed_offset)
	return last_processed_offset, err
}

const kafkaJournalUpsert = `-- name: KafkaJournalUpsert :exec
INSERT INTO kafka_offset_journal (consumer_group, topic, partition, last_processed_offset, updated_at)
VALUES ($1, $2, $3, $4, NOW())
ON CONFLICT (consumer_group, topic, partition)
DO UPDATE SET
    last_processed_offset = EXCLUDED.last_processed_offset,
    updated_at = NOW()
WHERE kafka_offset_journal.last_processed_offset < EXCLUDED.last_processed_offset
`

type KafkaJournalUpsertParams struct {
	ConsumerGroup       string `json:"consumer_group"`
	Topic               string `json:"topic"`
	Partition           int32  `json:"partition"`
	LastProcessedOffset int64  `json:"last_processed_offset"`
}

// Insert or update the last processed offset for a consumer group, topic, and partition
// Only updates if the new offset is greater than the existing one
func (q *Queries) KafkaJournalUpsert(ctx context.Context, arg KafkaJournalUpsertParams) error {
	_, err := q.db.Exec(ctx, kafkaJournalUpsert,
		arg.ConsumerGroup,
		arg.Topic,
		arg.Partition,
		arg.LastProcessedOffset,
	)
	return err
}

const kafkaJournalUpsertWithOrgInstance = `-- name: KafkaJournalUpsertWithOrgInstance :exec
INSERT INTO kafka_offset_journal (consumer_group, topic, partition, organization_id, instance_num, last_processed_offset, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, NOW())
ON CONFLICT (consumer_group, topic, partition, organization_id, instance_num)
DO UPDATE SET
    last_processed_offset = EXCLUDED.last_processed_offset,
    updated_at = NOW()
WHERE kafka_offset_journal.last_processed_offset < EXCLUDED.last_processed_offset
`

type KafkaJournalUpsertWithOrgInstanceParams struct {
	ConsumerGroup       string    `json:"consumer_group"`
	Topic               string    `json:"topic"`
	Partition           int32     `json:"partition"`
	OrganizationID      uuid.UUID `json:"organization_id"`
	InstanceNum         int16     `json:"instance_num"`
	LastProcessedOffset int64     `json:"last_processed_offset"`
}

// Insert or update the last processed offset for a consumer group, topic, partition, organization, and instance
// Only updates if the new offset is greater than the existing one
func (q *Queries) KafkaJournalUpsertWithOrgInstance(ctx context.Context, arg KafkaJournalUpsertWithOrgInstanceParams) error {
	_, err := q.db.Exec(ctx, kafkaJournalUpsertWithOrgInstance,
		arg.ConsumerGroup,
		arg.Topic,
		arg.Partition,
		arg.OrganizationID,
		arg.InstanceNum,
		arg.LastProcessedOffset,
	)
	return err
}
