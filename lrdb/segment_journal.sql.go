// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: segment_journal.sql

package lrdb

import (
	"context"

	"github.com/google/uuid"
)

const getLatestSegmentJournal = `-- name: GetLatestSegmentJournal :one
SELECT id, signal, action, created_at, organization_id, instance_num, dateint, source_count, source_object_keys, source_total_records, source_total_size, dest_count, dest_object_keys, dest_total_records, dest_total_size, metadata, record_estimate, source_min_timestamp, source_max_timestamp, dest_min_timestamp, dest_max_timestamp, source_frequency_ms, dest_frequency_ms
FROM segment_journal
ORDER BY created_at DESC
LIMIT 1
`

// Get the most recent segment_journal entry
func (q *Queries) GetLatestSegmentJournal(ctx context.Context) (SegmentJournal, error) {
	row := q.db.QueryRow(ctx, getLatestSegmentJournal)
	var i SegmentJournal
	err := row.Scan(
		&i.ID,
		&i.Signal,
		&i.Action,
		&i.CreatedAt,
		&i.OrganizationID,
		&i.InstanceNum,
		&i.Dateint,
		&i.SourceCount,
		&i.SourceObjectKeys,
		&i.SourceTotalRecords,
		&i.SourceTotalSize,
		&i.DestCount,
		&i.DestObjectKeys,
		&i.DestTotalRecords,
		&i.DestTotalSize,
		&i.Metadata,
		&i.RecordEstimate,
		&i.SourceMinTimestamp,
		&i.SourceMaxTimestamp,
		&i.DestMinTimestamp,
		&i.DestMaxTimestamp,
		&i.SourceFrequencyMs,
		&i.DestFrequencyMs,
	)
	return i, err
}

const getSegmentJournalByID = `-- name: GetSegmentJournalByID :one
SELECT id, signal, action, created_at, organization_id, instance_num, dateint, source_count, source_object_keys, source_total_records, source_total_size, dest_count, dest_object_keys, dest_total_records, dest_total_size, metadata, record_estimate, source_min_timestamp, source_max_timestamp, dest_min_timestamp, dest_max_timestamp, source_frequency_ms, dest_frequency_ms
FROM segment_journal
WHERE id = $1
`

// Get a specific segment_journal entry by ID
func (q *Queries) GetSegmentJournalByID(ctx context.Context, id int64) (SegmentJournal, error) {
	row := q.db.QueryRow(ctx, getSegmentJournalByID, id)
	var i SegmentJournal
	err := row.Scan(
		&i.ID,
		&i.Signal,
		&i.Action,
		&i.CreatedAt,
		&i.OrganizationID,
		&i.InstanceNum,
		&i.Dateint,
		&i.SourceCount,
		&i.SourceObjectKeys,
		&i.SourceTotalRecords,
		&i.SourceTotalSize,
		&i.DestCount,
		&i.DestObjectKeys,
		&i.DestTotalRecords,
		&i.DestTotalSize,
		&i.Metadata,
		&i.RecordEstimate,
		&i.SourceMinTimestamp,
		&i.SourceMaxTimestamp,
		&i.DestMinTimestamp,
		&i.DestMaxTimestamp,
		&i.SourceFrequencyMs,
		&i.DestFrequencyMs,
	)
	return i, err
}

const insertSegmentJournal = `-- name: InsertSegmentJournal :exec
INSERT INTO segment_journal (
    signal,
    action,
    organization_id,
    instance_num,
    dateint,
    source_count,
    source_object_keys,
    source_total_records,
    source_total_size,
    dest_count,
    dest_object_keys,
    dest_total_records,
    dest_total_size,
    record_estimate,
    metadata,
    source_min_timestamp,
    source_max_timestamp,
    dest_min_timestamp,
    dest_max_timestamp,
    source_frequency_ms,
    dest_frequency_ms
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    $15,
    $16,
    $17,
    $18,
    $19,
    $20,
    $21
)
`

type InsertSegmentJournalParams struct {
	Signal             int16          `json:"signal"`
	Action             int16          `json:"action"`
	OrganizationID     uuid.UUID      `json:"organization_id"`
	InstanceNum        int16          `json:"instance_num"`
	Dateint            int32          `json:"dateint"`
	SourceCount        int32          `json:"source_count"`
	SourceObjectKeys   []string       `json:"source_object_keys"`
	SourceTotalRecords int64          `json:"source_total_records"`
	SourceTotalSize    int64          `json:"source_total_size"`
	DestCount          int32          `json:"dest_count"`
	DestObjectKeys     []string       `json:"dest_object_keys"`
	DestTotalRecords   int64          `json:"dest_total_records"`
	DestTotalSize      int64          `json:"dest_total_size"`
	RecordEstimate     int64          `json:"record_estimate"`
	Metadata           map[string]any `json:"metadata"`
	SourceMinTimestamp int64          `json:"source_min_timestamp"`
	SourceMaxTimestamp int64          `json:"source_max_timestamp"`
	DestMinTimestamp   int64          `json:"dest_min_timestamp"`
	DestMaxTimestamp   int64          `json:"dest_max_timestamp"`
	SourceFrequencyMs  int32          `json:"source_frequency_ms"`
	DestFrequencyMs    int32          `json:"dest_frequency_ms"`
}

// Insert a debugging journal entry for segment operations
func (q *Queries) InsertSegmentJournal(ctx context.Context, arg InsertSegmentJournalParams) error {
	_, err := q.db.Exec(ctx, insertSegmentJournal,
		arg.Signal,
		arg.Action,
		arg.OrganizationID,
		arg.InstanceNum,
		arg.Dateint,
		arg.SourceCount,
		arg.SourceObjectKeys,
		arg.SourceTotalRecords,
		arg.SourceTotalSize,
		arg.DestCount,
		arg.DestObjectKeys,
		arg.DestTotalRecords,
		arg.DestTotalSize,
		arg.RecordEstimate,
		arg.Metadata,
		arg.SourceMinTimestamp,
		arg.SourceMaxTimestamp,
		arg.DestMinTimestamp,
		arg.DestMaxTimestamp,
		arg.SourceFrequencyMs,
		arg.DestFrequencyMs,
	)
	return err
}
