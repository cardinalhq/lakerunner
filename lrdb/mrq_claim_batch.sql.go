// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: mrq_claim_batch.sql

package lrdb

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const claimMetricRollupWork = `-- name: ClaimMetricRollupWork :many
WITH
params AS (
  SELECT
    $1::bigint                               AS worker_id,
    COALESCE($2::timestamptz, now())  AS now_ts,
    $3::integer                        AS max_age_seconds,
    $4::integer                            AS batch_count
),

seeds_per_group AS (
  SELECT DISTINCT ON (organization_id, dateint, frequency_ms, instance_num, slot_id, slot_count)
         id AS seed_id, organization_id, dateint, frequency_ms, instance_num, slot_id, slot_count,
         priority, queue_ts
  FROM metric_rollup_queue
  WHERE claimed_at IS NULL
  ORDER BY organization_id, dateint, frequency_ms, instance_num, slot_id, slot_count, 
           priority DESC, queue_ts ASC, id ASC
),

ordered_groups AS (
  SELECT s.seed_id, s.organization_id, s.dateint, s.frequency_ms, s.instance_num, s.slot_id, s.slot_count, s.priority, s.queue_ts,
         ROW_NUMBER() OVER (ORDER BY s.priority DESC, s.queue_ts ASC, s.seed_id ASC) AS seed_rank
  FROM seeds_per_group s
),

group_flags AS (
  SELECT
    og.organization_id, og.dateint, og.frequency_ms, og.instance_num, og.slot_id, og.slot_count,
    og.priority, og.queue_ts, og.seed_rank,
    ((p.now_ts - og.queue_ts) > make_interval(secs => p.max_age_seconds)) AS is_old,
    p.batch_count,
    p.now_ts
  FROM ordered_groups og
  CROSS JOIN params p
),

grp_scope AS (
  SELECT
    q.id, q.organization_id, q.dateint, q.frequency_ms, q.instance_num, 
    q.slot_id, q.slot_count, q.priority, q.queue_ts,
    gf.seed_rank, gf.is_old, gf.batch_count
  FROM metric_rollup_queue q
  JOIN group_flags gf
    ON q.claimed_at   IS NULL
   AND q.organization_id = gf.organization_id
   AND q.dateint         = gf.dateint
   AND q.frequency_ms    = gf.frequency_ms
   AND q.instance_num    = gf.instance_num
   AND q.slot_id         = gf.slot_id
   AND q.slot_count      = gf.slot_count
),

pack AS (
  SELECT
    g.id, g.organization_id, g.dateint, g.frequency_ms, g.instance_num, g.slot_id, g.slot_count, g.priority, g.queue_ts, g.seed_rank, g.is_old, g.batch_count,
    ROW_NUMBER() OVER (
      PARTITION BY g.organization_id, g.dateint, g.frequency_ms, g.instance_num, g.slot_id, g.slot_count
      ORDER BY g.priority DESC, g.queue_ts ASC, g.id ASC
    ) AS rn
  FROM grp_scope g
),

prelim AS (
  SELECT p.id, p.organization_id, p.dateint, p.frequency_ms, p.instance_num, p.slot_id, p.slot_count, p.priority, p.queue_ts, p.seed_rank, p.is_old, p.batch_count, p.rn
  FROM pack p
  JOIN group_flags gf
    ON gf.organization_id = p.organization_id
   AND gf.dateint         = p.dateint
   AND gf.frequency_ms    = p.frequency_ms
   AND gf.instance_num    = p.instance_num
   AND gf.slot_id         = p.slot_id
   AND gf.slot_count      = p.slot_count
  WHERE p.rn <= gf.batch_count
),

prelim_stats AS (
  SELECT
    organization_id, dateint, frequency_ms, instance_num, slot_id, slot_count,
    COUNT(*) AS n_rows,
    MIN(seed_rank) AS seed_rank
  FROM prelim
  GROUP BY organization_id, dateint, frequency_ms, instance_num, slot_id, slot_count
),

eligible_groups AS (
  SELECT
    gf.organization_id, gf.dateint, gf.frequency_ms, gf.instance_num, 
    gf.slot_id, gf.slot_count, gf.seed_rank
  FROM group_flags gf
  JOIN prelim_stats ps
    ON ps.organization_id = gf.organization_id
   AND ps.dateint         = gf.dateint
   AND ps.frequency_ms    = gf.frequency_ms
   AND ps.instance_num    = gf.instance_num
   AND ps.slot_id         = gf.slot_id
   AND ps.slot_count      = gf.slot_count
  WHERE (NOT gf.is_old AND ps.n_rows >= 1)
     OR (gf.is_old      AND ps.n_rows > 0)
),

winner_group AS (
  SELECT eg.organization_id, eg.dateint, eg.frequency_ms, eg.instance_num, eg.slot_id, eg.slot_count, eg.seed_rank
  FROM eligible_groups eg
  WHERE eg.seed_rank = (SELECT MIN(seed_rank) FROM eligible_groups)
),

group_chosen AS (
  SELECT pr.id, pr.organization_id, pr.dateint, pr.frequency_ms, pr.instance_num,
         pr.slot_id, pr.slot_count, pr.priority
  FROM prelim pr
  JOIN winner_group w
    ON w.organization_id = pr.organization_id
   AND w.dateint         = pr.dateint
   AND w.frequency_ms    = pr.frequency_ms
   AND w.instance_num    = pr.instance_num
   AND w.slot_id         = pr.slot_id
   AND w.slot_count      = pr.slot_count
),

upd AS (
  UPDATE metric_rollup_queue q
  SET claimed_by = (SELECT worker_id FROM params),
      claimed_at = (SELECT now_ts FROM params),
      heartbeated_at = (SELECT now_ts FROM params)
  FROM group_chosen c
  WHERE q.id = c.id
    AND q.claimed_at IS NULL
  RETURNING q.id, q.queue_ts, q.priority, q.organization_id, q.dateint, q.frequency_ms, q.instance_num, q.slot_id, q.slot_count, q.tries, q.claimed_by, q.claimed_at, q.heartbeated_at, q.segment_id
)
SELECT id, queue_ts, priority, organization_id, dateint, frequency_ms, instance_num, slot_id, slot_count, tries, claimed_by, claimed_at, heartbeated_at, segment_id FROM upd
ORDER BY priority DESC, queue_ts ASC, id ASC
`

type ClaimMetricRollupWorkParams struct {
	WorkerID      int64      `json:"worker_id"`
	NowTs         *time.Time `json:"now_ts"`
	MaxAgeSeconds int32      `json:"max_age_seconds"`
	BatchCount    int32      `json:"batch_count"`
}

type ClaimMetricRollupWorkRow struct {
	ID             int64      `json:"id"`
	QueueTs        time.Time  `json:"queue_ts"`
	Priority       int32      `json:"priority"`
	OrganizationID uuid.UUID  `json:"organization_id"`
	Dateint        int32      `json:"dateint"`
	FrequencyMs    int64      `json:"frequency_ms"`
	InstanceNum    int16      `json:"instance_num"`
	SlotID         int32      `json:"slot_id"`
	SlotCount      int32      `json:"slot_count"`
	Tries          int32      `json:"tries"`
	ClaimedBy      int64      `json:"claimed_by"`
	ClaimedAt      *time.Time `json:"claimed_at"`
	HeartbeatedAt  *time.Time `json:"heartbeated_at"`
	SegmentID      int64      `json:"segment_id"`
}

// 1) One seed per group (org, dateint, freq, instance, slot_id, slot_count)
// 2) Order groups globally by seed recency/priority
// 3) Attach per-group flags
// 4) All ready rows within each group
// 5) Limit per group
// 6) Rows that fit under caps
// 7) Totals per group
// 8) Eligibility: fresh = at least 1, old = any positive
// 9) Pick earliest eligible group
// 10) Rows to claim for the winner group
// 11) Atomic optimistic claim
func (q *Queries) ClaimMetricRollupWork(ctx context.Context, arg ClaimMetricRollupWorkParams) ([]ClaimMetricRollupWorkRow, error) {
	rows, err := q.db.Query(ctx, claimMetricRollupWork,
		arg.WorkerID,
		arg.NowTs,
		arg.MaxAgeSeconds,
		arg.BatchCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ClaimMetricRollupWorkRow
	for rows.Next() {
		var i ClaimMetricRollupWorkRow
		if err := rows.Scan(
			&i.ID,
			&i.QueueTs,
			&i.Priority,
			&i.OrganizationID,
			&i.Dateint,
			&i.FrequencyMs,
			&i.InstanceNum,
			&i.SlotID,
			&i.SlotCount,
			&i.Tries,
			&i.ClaimedBy,
			&i.ClaimedAt,
			&i.HeartbeatedAt,
			&i.SegmentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
