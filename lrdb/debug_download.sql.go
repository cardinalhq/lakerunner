// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: debug_download.sql

package lrdb

import (
	"context"

	"github.com/google/uuid"
)

const getLogSegmentsForDownload = `-- name: GetLogSegmentsForDownload :many
SELECT organization_id, dateint, segment_id, instance_num, fingerprints, record_count, file_size, ingest_dateint, ts_range, created_by, created_at, compacted, published, label_name_map, stream_ids
FROM log_seg
WHERE organization_id = $1
  AND dateint >= $2
  AND dateint <= $3
  AND ts_range && int8range($4, $5, '[)')
  AND published = true
ORDER BY dateint, segment_id
`

type GetLogSegmentsForDownloadParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	StartDateint   int32     `json:"start_dateint"`
	EndDateint     int32     `json:"end_dateint"`
	StartTime      int64     `json:"start_time"`
	EndTime        int64     `json:"end_time"`
}

func (q *Queries) GetLogSegmentsForDownload(ctx context.Context, arg GetLogSegmentsForDownloadParams) ([]LogSeg, error) {
	rows, err := q.db.Query(ctx, getLogSegmentsForDownload,
		arg.OrganizationID,
		arg.StartDateint,
		arg.EndDateint,
		arg.StartTime,
		arg.EndTime,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LogSeg
	for rows.Next() {
		var i LogSeg
		if err := rows.Scan(
			&i.OrganizationID,
			&i.Dateint,
			&i.SegmentID,
			&i.InstanceNum,
			&i.Fingerprints,
			&i.RecordCount,
			&i.FileSize,
			&i.IngestDateint,
			&i.TsRange,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.Compacted,
			&i.Published,
			&i.LabelNameMap,
			&i.StreamIds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMetricSegmentsForDownload = `-- name: GetMetricSegmentsForDownload :many
SELECT organization_id, dateint, frequency_ms, segment_id, instance_num, ts_range, record_count, file_size, ingest_dateint, published, rolledup, created_at, created_by, fingerprints, sort_version, compacted, label_name_map
FROM metric_seg
WHERE organization_id = $1
  AND dateint >= $2
  AND dateint <= $3
  AND ts_range && int8range($4, $5, '[)')
  AND published = true
  AND frequency_ms = $6
ORDER BY dateint, segment_id
`

type GetMetricSegmentsForDownloadParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	StartDateint   int32     `json:"start_dateint"`
	EndDateint     int32     `json:"end_dateint"`
	StartTime      int64     `json:"start_time"`
	EndTime        int64     `json:"end_time"`
	FrequencyMs    int32     `json:"frequency_ms"`
}

func (q *Queries) GetMetricSegmentsForDownload(ctx context.Context, arg GetMetricSegmentsForDownloadParams) ([]MetricSeg, error) {
	rows, err := q.db.Query(ctx, getMetricSegmentsForDownload,
		arg.OrganizationID,
		arg.StartDateint,
		arg.EndDateint,
		arg.StartTime,
		arg.EndTime,
		arg.FrequencyMs,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MetricSeg
	for rows.Next() {
		var i MetricSeg
		if err := rows.Scan(
			&i.OrganizationID,
			&i.Dateint,
			&i.FrequencyMs,
			&i.SegmentID,
			&i.InstanceNum,
			&i.TsRange,
			&i.RecordCount,
			&i.FileSize,
			&i.IngestDateint,
			&i.Published,
			&i.Rolledup,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.Fingerprints,
			&i.SortVersion,
			&i.Compacted,
			&i.LabelNameMap,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTraceSegmentsForDownload = `-- name: GetTraceSegmentsForDownload :many
SELECT organization_id, dateint, segment_id, instance_num, fingerprints, record_count, file_size, ingest_dateint, ts_range, created_by, created_at, compacted, published, label_name_map
FROM trace_seg
WHERE organization_id = $1
  AND dateint >= $2
  AND dateint <= $3
  AND ts_range && int8range($4, $5, '[)')
  AND published = true
ORDER BY dateint, segment_id
`

type GetTraceSegmentsForDownloadParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	StartDateint   int32     `json:"start_dateint"`
	EndDateint     int32     `json:"end_dateint"`
	StartTime      int64     `json:"start_time"`
	EndTime        int64     `json:"end_time"`
}

func (q *Queries) GetTraceSegmentsForDownload(ctx context.Context, arg GetTraceSegmentsForDownloadParams) ([]TraceSeg, error) {
	rows, err := q.db.Query(ctx, getTraceSegmentsForDownload,
		arg.OrganizationID,
		arg.StartDateint,
		arg.EndDateint,
		arg.StartTime,
		arg.EndTime,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TraceSeg
	for rows.Next() {
		var i TraceSeg
		if err := rows.Scan(
			&i.OrganizationID,
			&i.Dateint,
			&i.SegmentID,
			&i.InstanceNum,
			&i.Fingerprints,
			&i.RecordCount,
			&i.FileSize,
			&i.IngestDateint,
			&i.TsRange,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.Compacted,
			&i.Published,
			&i.LabelNameMap,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
