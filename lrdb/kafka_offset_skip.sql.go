// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: kafka_offset_skip.sql

package lrdb

import (
	"context"
	"time"
)

const cleanupKafkaOffsetSkipsByAge = `-- name: CleanupKafkaOffsetSkipsByAge :execrows
DELETE FROM kafka_offset_skip
WHERE created_at < $1
`

func (q *Queries) CleanupKafkaOffsetSkipsByAge(ctx context.Context, createdBefore time.Time) (int64, error) {
	result, err := q.db.Exec(ctx, cleanupKafkaOffsetSkipsByAge, createdBefore)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteKafkaOffsetSkip = `-- name: DeleteKafkaOffsetSkip :exec
DELETE FROM kafka_offset_skip
WHERE consumer_group = $1
  AND topic = $2
  AND partition_id = $3
  AND skip_to_offset = $4
`

type DeleteKafkaOffsetSkipParams struct {
	ConsumerGroup string `json:"consumer_group"`
	Topic         string `json:"topic"`
	PartitionID   int32  `json:"partition_id"`
	SkipToOffset  int64  `json:"skip_to_offset"`
}

func (q *Queries) DeleteKafkaOffsetSkip(ctx context.Context, arg DeleteKafkaOffsetSkipParams) error {
	_, err := q.db.Exec(ctx, deleteKafkaOffsetSkip,
		arg.ConsumerGroup,
		arg.Topic,
		arg.PartitionID,
		arg.SkipToOffset,
	)
	return err
}

const deleteKafkaOffsetSkipsForGroup = `-- name: DeleteKafkaOffsetSkipsForGroup :execrows
DELETE FROM kafka_offset_skip
WHERE consumer_group = $1
`

func (q *Queries) DeleteKafkaOffsetSkipsForGroup(ctx context.Context, consumerGroup string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteKafkaOffsetSkipsForGroup, consumerGroup)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getKafkaOffsetSkips = `-- name: GetKafkaOffsetSkips :many
SELECT consumer_group, topic, partition_id, skip_to_offset, created_at
FROM kafka_offset_skip
WHERE consumer_group = $1
  AND topic = $2
`

type GetKafkaOffsetSkipsParams struct {
	ConsumerGroup string `json:"consumer_group"`
	Topic         string `json:"topic"`
}

type GetKafkaOffsetSkipsRow struct {
	ConsumerGroup string    `json:"consumer_group"`
	Topic         string    `json:"topic"`
	PartitionID   int32     `json:"partition_id"`
	SkipToOffset  int64     `json:"skip_to_offset"`
	CreatedAt     time.Time `json:"created_at"`
}

func (q *Queries) GetKafkaOffsetSkips(ctx context.Context, arg GetKafkaOffsetSkipsParams) ([]GetKafkaOffsetSkipsRow, error) {
	rows, err := q.db.Query(ctx, getKafkaOffsetSkips, arg.ConsumerGroup, arg.Topic)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetKafkaOffsetSkipsRow
	for rows.Next() {
		var i GetKafkaOffsetSkipsRow
		if err := rows.Scan(
			&i.ConsumerGroup,
			&i.Topic,
			&i.PartitionID,
			&i.SkipToOffset,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getKafkaOffsetSkipsForGroup = `-- name: GetKafkaOffsetSkipsForGroup :many
SELECT consumer_group, topic, partition_id, skip_to_offset, created_at
FROM kafka_offset_skip
WHERE consumer_group = $1
`

type GetKafkaOffsetSkipsForGroupRow struct {
	ConsumerGroup string    `json:"consumer_group"`
	Topic         string    `json:"topic"`
	PartitionID   int32     `json:"partition_id"`
	SkipToOffset  int64     `json:"skip_to_offset"`
	CreatedAt     time.Time `json:"created_at"`
}

func (q *Queries) GetKafkaOffsetSkipsForGroup(ctx context.Context, consumerGroup string) ([]GetKafkaOffsetSkipsForGroupRow, error) {
	rows, err := q.db.Query(ctx, getKafkaOffsetSkipsForGroup, consumerGroup)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetKafkaOffsetSkipsForGroupRow
	for rows.Next() {
		var i GetKafkaOffsetSkipsForGroupRow
		if err := rows.Scan(
			&i.ConsumerGroup,
			&i.Topic,
			&i.PartitionID,
			&i.SkipToOffset,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertKafkaOffsetSkip = `-- name: InsertKafkaOffsetSkip :exec
INSERT INTO kafka_offset_skip (
  consumer_group,
  topic,
  partition_id,
  skip_to_offset,
  created_at
) VALUES (
  $1,
  $2,
  $3,
  $4,
  COALESCE($5::timestamptz, now())
)
ON CONFLICT (consumer_group, topic, partition_id)
DO UPDATE SET
  skip_to_offset = EXCLUDED.skip_to_offset,
  created_at = EXCLUDED.created_at
`

type InsertKafkaOffsetSkipParams struct {
	ConsumerGroup string     `json:"consumer_group"`
	Topic         string     `json:"topic"`
	PartitionID   int32      `json:"partition_id"`
	SkipToOffset  int64      `json:"skip_to_offset"`
	CreatedAt     *time.Time `json:"created_at"`
}

func (q *Queries) InsertKafkaOffsetSkip(ctx context.Context, arg InsertKafkaOffsetSkipParams) error {
	_, err := q.db.Exec(ctx, insertKafkaOffsetSkip,
		arg.ConsumerGroup,
		arg.Topic,
		arg.PartitionID,
		arg.SkipToOffset,
		arg.CreatedAt,
	)
	return err
}
