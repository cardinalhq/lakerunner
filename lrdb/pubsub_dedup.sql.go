// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: pubsub_dedup.sql

package lrdb

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgconn"
)

const pubSubMessageHistoryCleanup = `-- name: PubSubMessageHistoryCleanup :execresult
DELETE FROM pubsub_message_history
WHERE (bucket, object_id, source) IN (
    SELECT pmh.bucket, pmh.object_id, pmh.source
    FROM pubsub_message_history pmh
    WHERE pmh.received_at < $1
    ORDER BY pmh.received_at
    LIMIT $2
)
`

type PubSubMessageHistoryCleanupParams struct {
	AgeThreshold time.Time `json:"age_threshold"`
	BatchSize    int32     `json:"batch_size"`
}

func (q *Queries) PubSubMessageHistoryCleanup(ctx context.Context, arg PubSubMessageHistoryCleanupParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, pubSubMessageHistoryCleanup, arg.AgeThreshold, arg.BatchSize)
}

const pubSubMessageHistoryCount = `-- name: PubSubMessageHistoryCount :one
SELECT COUNT(*) as total_count
FROM pubsub_message_history
`

func (q *Queries) PubSubMessageHistoryCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, pubSubMessageHistoryCount)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const pubSubMessageHistoryGetRecentForBucket = `-- name: PubSubMessageHistoryGetRecentForBucket :many
SELECT bucket, object_id, source, received_at
FROM pubsub_message_history
WHERE bucket = $1
ORDER BY received_at DESC
LIMIT $2
`

type PubSubMessageHistoryGetRecentForBucketParams struct {
	Bucket     string `json:"bucket"`
	LimitCount int32  `json:"limit_count"`
}

func (q *Queries) PubSubMessageHistoryGetRecentForBucket(ctx context.Context, arg PubSubMessageHistoryGetRecentForBucketParams) ([]PubsubMessageHistory, error) {
	rows, err := q.db.Query(ctx, pubSubMessageHistoryGetRecentForBucket, arg.Bucket, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PubsubMessageHistory
	for rows.Next() {
		var i PubsubMessageHistory
		if err := rows.Scan(
			&i.Bucket,
			&i.ObjectID,
			&i.Source,
			&i.ReceivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pubSubMessageHistoryInsert = `-- name: PubSubMessageHistoryInsert :execresult
INSERT INTO pubsub_message_history (
    bucket, object_id, source
) VALUES (
    $1, $2, $3
) ON CONFLICT (bucket, object_id, source) DO NOTHING
`

type PubSubMessageHistoryInsertParams struct {
	Bucket   string `json:"bucket"`
	ObjectID string `json:"object_id"`
	Source   string `json:"source"`
}

func (q *Queries) PubSubMessageHistoryInsert(ctx context.Context, arg PubSubMessageHistoryInsertParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, pubSubMessageHistoryInsert, arg.Bucket, arg.ObjectID, arg.Source)
}

const pubSubMessageHistoryInsertBatch = `-- name: PubSubMessageHistoryInsertBatch :many
INSERT INTO pubsub_message_history (bucket, object_id, source)
SELECT unnest($1::text[]), unnest($2::text[]), unnest($3::text[])
ON CONFLICT (bucket, object_id, source) DO NOTHING
RETURNING bucket, object_id
`

type PubSubMessageHistoryInsertBatchParams struct {
	Buckets   []string `json:"buckets"`
	ObjectIds []string `json:"object_ids"`
	Sources   []string `json:"sources"`
}

type PubSubMessageHistoryInsertBatchRow struct {
	Bucket   string `json:"bucket"`
	ObjectID string `json:"object_id"`
}

func (q *Queries) PubSubMessageHistoryInsertBatch(ctx context.Context, arg PubSubMessageHistoryInsertBatchParams) ([]PubSubMessageHistoryInsertBatchRow, error) {
	rows, err := q.db.Query(ctx, pubSubMessageHistoryInsertBatch, arg.Buckets, arg.ObjectIds, arg.Sources)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PubSubMessageHistoryInsertBatchRow
	for rows.Next() {
		var i PubSubMessageHistoryInsertBatchRow
		if err := rows.Scan(&i.Bucket, &i.ObjectID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
