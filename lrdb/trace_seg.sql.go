// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: trace_seg.sql

package lrdb

import (
	"context"

	"github.com/google/uuid"
)

const getTraceSeg = `-- name: GetTraceSeg :one
SELECT organization_id, dateint, segment_id, instance_num, fingerprints, record_count, file_size, ingest_dateint, ts_range, created_by, created_at, compacted, published
FROM trace_seg
WHERE organization_id = $1
  AND dateint = $2
  AND segment_id = $3
  AND instance_num = $4
`

type GetTraceSegParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	SegmentID      int64     `json:"segment_id"`
	InstanceNum    int16     `json:"instance_num"`
}

func (q *Queries) GetTraceSeg(ctx context.Context, arg GetTraceSegParams) (TraceSeg, error) {
	row := q.db.QueryRow(ctx, getTraceSeg,
		arg.OrganizationID,
		arg.Dateint,
		arg.SegmentID,
		arg.InstanceNum,
	)
	var i TraceSeg
	err := row.Scan(
		&i.OrganizationID,
		&i.Dateint,
		&i.SegmentID,
		&i.InstanceNum,
		&i.Fingerprints,
		&i.RecordCount,
		&i.FileSize,
		&i.IngestDateint,
		&i.TsRange,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.Compacted,
		&i.Published,
	)
	return i, err
}

const markTraceSegsCompactedByKeys = `-- name: MarkTraceSegsCompactedByKeys :exec
UPDATE trace_seg
SET compacted = true, published = false
WHERE organization_id = $1
  AND dateint         = $2
  AND instance_num    = $3
  AND segment_id      = ANY($4::bigint[])
  AND compacted       = false
`

type MarkTraceSegsCompactedByKeysParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	InstanceNum    int16     `json:"instance_num"`
	SegmentIds     []int64   `json:"segment_ids"`
}

func (q *Queries) MarkTraceSegsCompactedByKeys(ctx context.Context, arg MarkTraceSegsCompactedByKeysParams) error {
	_, err := q.db.Exec(ctx, markTraceSegsCompactedByKeys,
		arg.OrganizationID,
		arg.Dateint,
		arg.InstanceNum,
		arg.SegmentIds,
	)
	return err
}

const insertTraceSegmentDirect = `-- name: insertTraceSegmentDirect :exec
INSERT INTO trace_seg (
  organization_id,
  dateint,
  ingest_dateint,
  segment_id,
  instance_num,
  ts_range,
  record_count,
  file_size,
  created_by,
  fingerprints,
  published,
  compacted
)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  int8range($6, $7, '[)'),
  $8,
  $9,
  $10,
  $11::bigint[],
  $12,
  $13
)
`

type InsertTraceSegmentParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	IngestDateint  int32     `json:"ingest_dateint"`
	SegmentID      int64     `json:"segment_id"`
	InstanceNum    int16     `json:"instance_num"`
	StartTs        int64     `json:"start_ts"`
	EndTs          int64     `json:"end_ts"`
	RecordCount    int64     `json:"record_count"`
	FileSize       int64     `json:"file_size"`
	CreatedBy      CreatedBy `json:"created_by"`
	Fingerprints   []int64   `json:"fingerprints"`
	Published      bool      `json:"published"`
	Compacted      bool      `json:"compacted"`
}

func (q *Queries) insertTraceSegmentDirect(ctx context.Context, arg InsertTraceSegmentParams) error {
	_, err := q.db.Exec(ctx, insertTraceSegmentDirect,
		arg.OrganizationID,
		arg.Dateint,
		arg.IngestDateint,
		arg.SegmentID,
		arg.InstanceNum,
		arg.StartTs,
		arg.EndTs,
		arg.RecordCount,
		arg.FileSize,
		arg.CreatedBy,
		arg.Fingerprints,
		arg.Published,
		arg.Compacted,
	)
	return err
}
