// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: list_service_metrics.sql

package lrdb

import (
	"context"

	"github.com/google/uuid"
)

const listServiceMetrics = `-- name: ListServiceMetrics :many
SELECT DISTINCT em.metric_name
FROM lrdb_exemplar_metrics em
WHERE em.organization_id = $1
  AND em.attributes->>'service.name' = $2::text
  AND (
    (
      em.updated_at IS NOT NULL
      AND em.updated_at >= COALESCE(to_timestamp($3/ 1000.0), NOW() - interval '1 day')
      AND em.updated_at <= COALESCE(to_timestamp($4/ 1000.0), NOW())
    )
    OR (
      em.updated_at IS NULL
      AND em.created_at >= COALESCE(to_timestamp($3/ 1000.0), NOW() - interval '1 day')
      AND em.created_at <= COALESCE(to_timestamp($4/ 1000.0), NOW())
    )
  )
ORDER BY em.metric_name
`

type ListServiceMetricsParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	ServiceName    string    `json:"service_name"`
	StartTime      float64   `json:"/start_time"`
	EndTime        float64   `json:"/end_time"`
}

func (q *Queries) ListServiceMetrics(ctx context.Context, arg ListServiceMetricsParams) ([]string, error) {
	rows, err := q.db.Query(ctx, listServiceMetrics,
		arg.OrganizationID,
		arg.ServiceName,
		arg.StartTime,
		arg.EndTime,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var metric_name string
		if err := rows.Scan(&metric_name); err != nil {
			return nil, err
		}
		items = append(items, metric_name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
