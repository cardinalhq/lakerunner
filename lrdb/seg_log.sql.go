// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: seg_log.sql

package lrdb

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const deleteOldSegLogs = `-- name: DeleteOldSegLogs :exec
DELETE FROM seg_log
WHERE created_at < $1
`

// Clean up old seg_log entries for maintenance
func (q *Queries) DeleteOldSegLogs(ctx context.Context, cutoffTime time.Time) error {
	_, err := q.db.Exec(ctx, deleteOldSegLogs, cutoffTime)
	return err
}

const getLatestSegLog = `-- name: GetLatestSegLog :one
SELECT id, signal, action, created_at, organization_id, instance_num, dateint, frequency_ms,
       source_count, source_object_keys, source_total_records, source_total_size,
       dest_count, dest_object_keys, dest_total_records, dest_total_size,
       metadata
FROM seg_log
ORDER BY created_at DESC
LIMIT 1
`

// Get the most recent seg_log entry
func (q *Queries) GetLatestSegLog(ctx context.Context) (SegLog, error) {
	row := q.db.QueryRow(ctx, getLatestSegLog)
	var i SegLog
	err := row.Scan(
		&i.ID,
		&i.Signal,
		&i.Action,
		&i.CreatedAt,
		&i.OrganizationID,
		&i.InstanceNum,
		&i.Dateint,
		&i.FrequencyMs,
		&i.SourceCount,
		&i.SourceObjectKeys,
		&i.SourceTotalRecords,
		&i.SourceTotalSize,
		&i.DestCount,
		&i.DestObjectKeys,
		&i.DestTotalRecords,
		&i.DestTotalSize,
		&i.Metadata,
	)
	return i, err
}

const getSegLogByID = `-- name: GetSegLogByID :one
SELECT id, signal, action, created_at, organization_id, instance_num, dateint, frequency_ms,
       source_count, source_object_keys, source_total_records, source_total_size,
       dest_count, dest_object_keys, dest_total_records, dest_total_size,
       metadata
FROM seg_log
WHERE id = $1
`

// Get a specific seg_log entry by ID
func (q *Queries) GetSegLogByID(ctx context.Context, id int64) (SegLog, error) {
	row := q.db.QueryRow(ctx, getSegLogByID, id)
	var i SegLog
	err := row.Scan(
		&i.ID,
		&i.Signal,
		&i.Action,
		&i.CreatedAt,
		&i.OrganizationID,
		&i.InstanceNum,
		&i.Dateint,
		&i.FrequencyMs,
		&i.SourceCount,
		&i.SourceObjectKeys,
		&i.SourceTotalRecords,
		&i.SourceTotalSize,
		&i.DestCount,
		&i.DestObjectKeys,
		&i.DestTotalRecords,
		&i.DestTotalSize,
		&i.Metadata,
	)
	return i, err
}

const getSegLogByOrg = `-- name: GetSegLogByOrg :many
SELECT id, signal, action, created_at, organization_id, instance_num, dateint, frequency_ms,
       source_count, source_object_keys, source_total_records, source_total_size,
       dest_count, dest_object_keys, dest_total_records, dest_total_size,
       metadata
FROM seg_log
WHERE organization_id = $1
  AND ($2::smallint IS NULL OR signal = $2)
  AND ($3::smallint IS NULL OR action = $3)
ORDER BY created_at DESC
LIMIT $4
`

type GetSegLogByOrgParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Signal         int16     `json:"signal"`
	Action         int16     `json:"action"`
	LimitVal       int32     `json:"limit_val"`
}

// Get seg_log entries for debugging, filtered by organization
func (q *Queries) GetSegLogByOrg(ctx context.Context, arg GetSegLogByOrgParams) ([]SegLog, error) {
	rows, err := q.db.Query(ctx, getSegLogByOrg,
		arg.OrganizationID,
		arg.Signal,
		arg.Action,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SegLog
	for rows.Next() {
		var i SegLog
		if err := rows.Scan(
			&i.ID,
			&i.Signal,
			&i.Action,
			&i.CreatedAt,
			&i.OrganizationID,
			&i.InstanceNum,
			&i.Dateint,
			&i.FrequencyMs,
			&i.SourceCount,
			&i.SourceObjectKeys,
			&i.SourceTotalRecords,
			&i.SourceTotalSize,
			&i.DestCount,
			&i.DestObjectKeys,
			&i.DestTotalRecords,
			&i.DestTotalSize,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertSegLog = `-- name: InsertSegLog :exec
INSERT INTO seg_log (
    signal,
    action,
    organization_id,
    instance_num,
    dateint,
    frequency_ms,
    source_count,
    source_object_keys,
    source_total_records,
    source_total_size,
    dest_count,
    dest_object_keys,
    dest_total_records,
    dest_total_size,
    metadata
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    $15
)
`

type InsertSegLogParams struct {
	Signal             int16          `json:"signal"`
	Action             int16          `json:"action"`
	OrganizationID     uuid.UUID      `json:"organization_id"`
	InstanceNum        int16          `json:"instance_num"`
	Dateint            int32          `json:"dateint"`
	FrequencyMs        int32          `json:"frequency_ms"`
	SourceCount        int32          `json:"source_count"`
	SourceObjectKeys   []string       `json:"source_object_keys"`
	SourceTotalRecords int64          `json:"source_total_records"`
	SourceTotalSize    int64          `json:"source_total_size"`
	DestCount          int32          `json:"dest_count"`
	DestObjectKeys     []string       `json:"dest_object_keys"`
	DestTotalRecords   int64          `json:"dest_total_records"`
	DestTotalSize      int64          `json:"dest_total_size"`
	Metadata           map[string]any `json:"metadata"`
}

// Insert a debugging log entry for segment operations
func (q *Queries) InsertSegLog(ctx context.Context, arg InsertSegLogParams) error {
	_, err := q.db.Exec(ctx, insertSegLog,
		arg.Signal,
		arg.Action,
		arg.OrganizationID,
		arg.InstanceNum,
		arg.Dateint,
		arg.FrequencyMs,
		arg.SourceCount,
		arg.SourceObjectKeys,
		arg.SourceTotalRecords,
		arg.SourceTotalSize,
		arg.DestCount,
		arg.DestObjectKeys,
		arg.DestTotalRecords,
		arg.DestTotalSize,
		arg.Metadata,
	)
	return err
}
