// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: work_queue.sql

package lrdb

import (
	"context"
	"encoding/json"

	"time"

	"github.com/google/uuid"
)

const workQueueAdd = `-- name: WorkQueueAdd :one
INSERT INTO work_queue (
  task_name,
  organization_id,
  instance_num,
  spec,
  priority
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5
)
RETURNING id, task_name, organization_id, instance_num, spec, tries, claimed_by, claimed_at, heartbeated_at, failed, failed_reason, created_at, priority
`

type WorkQueueAddParams struct {
	TaskName       string          `json:"task_name"`
	OrganizationID uuid.UUID       `json:"organization_id"`
	InstanceNum    int16           `json:"instance_num"`
	Spec           json.RawMessage `json:"spec"`
	Priority       int32           `json:"priority"`
}

func (q *Queries) WorkQueueAdd(ctx context.Context, arg WorkQueueAddParams) (WorkQueue, error) {
	row := q.db.QueryRow(ctx, workQueueAdd,
		arg.TaskName,
		arg.OrganizationID,
		arg.InstanceNum,
		arg.Spec,
		arg.Priority,
	)
	var i WorkQueue
	err := row.Scan(
		&i.ID,
		&i.TaskName,
		&i.OrganizationID,
		&i.InstanceNum,
		&i.Spec,
		&i.Tries,
		&i.ClaimedBy,
		&i.ClaimedAt,
		&i.HeartbeatedAt,
		&i.Failed,
		&i.FailedReason,
		&i.CreatedAt,
		&i.Priority,
	)
	return i, err
}

const workQueueClaim = `-- name: WorkQueueClaim :one
WITH next AS (
  SELECT id
  FROM work_queue wq
  WHERE wq.task_name = $2
    AND wq.claimed_by = -1
    AND wq.failed = false
  ORDER BY wq.priority, wq.id
  FOR UPDATE SKIP LOCKED
  LIMIT 1
)
UPDATE work_queue w
SET claimed_by     = $1,
    claimed_at     = now(),
    heartbeated_at = now()
FROM next
WHERE w.id = next.id
RETURNING w.id, w.task_name, w.organization_id, w.instance_num, w.spec, w.tries, w.claimed_by, w.claimed_at, w.heartbeated_at, w.failed, w.failed_reason, w.created_at, w.priority
`

type WorkQueueClaimParams struct {
	WorkerID int64  `json:"worker_id"`
	TaskName string `json:"task_name"`
}

func (q *Queries) WorkQueueClaim(ctx context.Context, arg WorkQueueClaimParams) (WorkQueue, error) {
	row := q.db.QueryRow(ctx, workQueueClaim, arg.WorkerID, arg.TaskName)
	var i WorkQueue
	err := row.Scan(
		&i.ID,
		&i.TaskName,
		&i.OrganizationID,
		&i.InstanceNum,
		&i.Spec,
		&i.Tries,
		&i.ClaimedBy,
		&i.ClaimedAt,
		&i.HeartbeatedAt,
		&i.Failed,
		&i.FailedReason,
		&i.CreatedAt,
		&i.Priority,
	)
	return i, err
}

const workQueueCleanup = `-- name: WorkQueueCleanup :exec
UPDATE work_queue
   SET claimed_by     = -1,
       claimed_at     = NULL,
       heartbeated_at = NULL
 WHERE claimed_by <> -1
   AND heartbeated_at < now() - $1::INTERVAL
`

func (q *Queries) WorkQueueCleanup(ctx context.Context, heartbeatTimeout time.Duration) error {
	_, err := q.db.Exec(ctx, workQueueCleanup, heartbeatTimeout)
	return err
}

const workQueueComplete = `-- name: WorkQueueComplete :exec
DELETE FROM work_queue
 WHERE id = $1
   AND claimed_by = $2
`

type WorkQueueCompleteParams struct {
	ID       int64 `json:"id"`
	WorkerID int64 `json:"worker_id"`
}

func (q *Queries) WorkQueueComplete(ctx context.Context, arg WorkQueueCompleteParams) error {
	_, err := q.db.Exec(ctx, workQueueComplete, arg.ID, arg.WorkerID)
	return err
}

const workQueueDepth = `-- name: WorkQueueDepth :one
SELECT COUNT(*) as depth
  FROM work_queue
 WHERE task_name = $1
   AND claimed_by = -1
   AND failed = false
`

func (q *Queries) WorkQueueDepth(ctx context.Context, taskName string) (int64, error) {
	row := q.db.QueryRow(ctx, workQueueDepth, taskName)
	var depth int64
	err := row.Scan(&depth)
	return depth, err
}

const workQueueDepthAll = `-- name: WorkQueueDepthAll :many
SELECT task_name, priority, COUNT(*) as depth
  FROM work_queue
 WHERE claimed_by = -1
   AND failed = false
 GROUP BY task_name, priority
`

type WorkQueueDepthAllRow struct {
	TaskName string `json:"task_name"`
	Priority int32  `json:"priority"`
	Depth    int64  `json:"depth"`
}

func (q *Queries) WorkQueueDepthAll(ctx context.Context) ([]WorkQueueDepthAllRow, error) {
	rows, err := q.db.Query(ctx, workQueueDepthAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkQueueDepthAllRow
	for rows.Next() {
		var i WorkQueueDepthAllRow
		if err := rows.Scan(&i.TaskName, &i.Priority, &i.Depth); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const workQueueFail = `-- name: WorkQueueFail :one
UPDATE work_queue
   SET claimed_by     = -1,
       claimed_at     = NULL,
       heartbeated_at = NULL,
       tries          = tries + 1,
       failed         = (tries + 1 >= $1),
       failed_reason  = COALESCE($2, failed_reason)
 WHERE id = $3
   AND claimed_by = $4
RETURNING tries
`

type WorkQueueFailParams struct {
	MaxRetries   int32   `json:"max_retries"`
	FailedReason *string `json:"failed_reason"`
	ID           int64   `json:"id"`
	WorkerID     int64   `json:"worker_id"`
}

func (q *Queries) WorkQueueFail(ctx context.Context, arg WorkQueueFailParams) (int32, error) {
	row := q.db.QueryRow(ctx, workQueueFail,
		arg.MaxRetries,
		arg.FailedReason,
		arg.ID,
		arg.WorkerID,
	)
	var tries int32
	err := row.Scan(&tries)
	return tries, err
}

const workQueueHeartbeat = `-- name: WorkQueueHeartbeat :exec
UPDATE work_queue
   SET heartbeated_at = now()
 WHERE id = ANY($1::BIGINT[])
   AND claimed_by = $2
`

type WorkQueueHeartbeatParams struct {
	Ids      []int64 `json:"ids"`
	WorkerID int64   `json:"worker_id"`
}

func (q *Queries) WorkQueueHeartbeat(ctx context.Context, arg WorkQueueHeartbeatParams) error {
	_, err := q.db.Exec(ctx, workQueueHeartbeat, arg.Ids, arg.WorkerID)
	return err
}

const workQueueStatus = `-- name: WorkQueueStatus :many
SELECT
  task_name,
  priority,
  COUNT(*) FILTER (WHERE claimed_by = -1 AND failed = false) as pending,
  COUNT(*) FILTER (WHERE claimed_by <> -1) as in_progress,
  COUNT(*) FILTER (WHERE failed = true) as failed,
  COUNT(DISTINCT claimed_by) FILTER (WHERE claimed_by <> -1) as workers
FROM work_queue
GROUP BY task_name, priority
ORDER BY task_name, priority
`

type WorkQueueStatusRow struct {
	TaskName   string `json:"task_name"`
	Priority   int32  `json:"priority"`
	Pending    int64  `json:"pending"`
	InProgress int64  `json:"in_progress"`
	Failed     int64  `json:"failed"`
	Workers    int64  `json:"workers"`
}

func (q *Queries) WorkQueueStatus(ctx context.Context) ([]WorkQueueStatusRow, error) {
	rows, err := q.db.Query(ctx, workQueueStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkQueueStatusRow
	for rows.Next() {
		var i WorkQueueStatusRow
		if err := rows.Scan(
			&i.TaskName,
			&i.Priority,
			&i.Pending,
			&i.InProgress,
			&i.Failed,
			&i.Workers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
