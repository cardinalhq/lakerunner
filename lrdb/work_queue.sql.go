// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: work_queue.sql

package lrdb

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const workQueueAddDirect = `-- name: WorkQueueAddDirect :exec
SELECT public.work_queue_add(
  $1      :: UUID,
  $2    :: SMALLINT,
  $3     :: INTEGER,
  $4   :: INTEGER,
  $5      :: signal_enum,
  $6      :: action_enum,
  $7    :: TSTZRANGE,
  $8 :: TIMESTAMPTZ,
  $9    :: INTEGER,
  $10     :: INTEGER
)
`

type WorkQueueAddParams struct {
	OrgID      uuid.UUID                        `json:"org_id"`
	Instance   int16                            `json:"instance"`
	Dateint    int32                            `json:"dateint"`
	Frequency  int32                            `json:"frequency"`
	Signal     SignalEnum                       `json:"signal"`
	Action     ActionEnum                       `json:"action"`
	TsRange    pgtype.Range[pgtype.Timestamptz] `json:"ts_range"`
	RunnableAt time.Time                        `json:"runnable_at"`
	Priority   int32                            `json:"priority"`
	SlotID     int32                            `json:"slot_id"`
}

func (q *Queries) WorkQueueAddDirect(ctx context.Context, arg WorkQueueAddParams) error {
	_, err := q.db.Exec(ctx, workQueueAddDirect,
		arg.OrgID,
		arg.Instance,
		arg.Dateint,
		arg.Frequency,
		arg.Signal,
		arg.Action,
		arg.TsRange,
		arg.RunnableAt,
		arg.Priority,
		arg.SlotID,
	)
	return err
}

const workQueueCleanupDirect = `-- name: WorkQueueCleanupDirect :many
WITH params AS (
  SELECT
    NOW() AS v_now,
    (SELECT value::interval
       FROM public.settings
      WHERE key = 'lock_ttl_dead') AS dead_ttl
),
expired AS (
  UPDATE public.work_queue w
  SET
    claimed_by     = -1,
    claimed_at     = NULL,
    heartbeated_at = params.v_now,
    needs_run      = TRUE
  FROM params
  WHERE
    w.claimed_by <> -1
    AND w.heartbeated_at < params.v_now - params.dead_ttl
  RETURNING w.id, w.priority, w.runnable_at, w.organization_id, w.instance_num, w.dateint, w.frequency_ms, w.signal, w.action, w.needs_run, w.tries, w.ts_range, w.claimed_by, w.claimed_at, w.heartbeated_at, w.slot_id
),
deleted_locks AS (
  DELETE FROM public.signal_locks sl
  USING expired e
  WHERE sl.work_id = e.id
  RETURNING sl.id
)
SELECT
  e.id, e.priority, e.runnable_at, e.organization_id, e.instance_num, e.dateint, e.frequency_ms, e.signal, e.action, e.needs_run, e.tries, e.ts_range, e.claimed_by, e.claimed_at, e.heartbeated_at, e.slot_id,
  (SELECT COUNT(*) FROM deleted_locks) AS locks_removed
FROM expired e
`

type WorkQueueCleanupRow struct {
	ID             int64                            `json:"id"`
	Priority       int32                            `json:"priority"`
	RunnableAt     time.Time                        `json:"runnable_at"`
	OrganizationID uuid.UUID                        `json:"organization_id"`
	InstanceNum    int16                            `json:"instance_num"`
	Dateint        int32                            `json:"dateint"`
	FrequencyMs    int32                            `json:"frequency_ms"`
	Signal         SignalEnum                       `json:"signal"`
	Action         ActionEnum                       `json:"action"`
	NeedsRun       bool                             `json:"needs_run"`
	Tries          int32                            `json:"tries"`
	TsRange        pgtype.Range[pgtype.Timestamptz] `json:"ts_range"`
	ClaimedBy      int64                            `json:"claimed_by"`
	ClaimedAt      *time.Time                       `json:"claimed_at"`
	HeartbeatedAt  time.Time                        `json:"heartbeated_at"`
	SlotID         int32                            `json:"slot_id"`
	LocksRemoved   int64                            `json:"locks_removed"`
}

func (q *Queries) WorkQueueCleanupDirect(ctx context.Context) ([]WorkQueueCleanupRow, error) {
	rows, err := q.db.Query(ctx, workQueueCleanupDirect)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkQueueCleanupRow
	for rows.Next() {
		var i WorkQueueCleanupRow
		if err := rows.Scan(
			&i.ID,
			&i.Priority,
			&i.RunnableAt,
			&i.OrganizationID,
			&i.InstanceNum,
			&i.Dateint,
			&i.FrequencyMs,
			&i.Signal,
			&i.Action,
			&i.NeedsRun,
			&i.Tries,
			&i.TsRange,
			&i.ClaimedBy,
			&i.ClaimedAt,
			&i.HeartbeatedAt,
			&i.SlotID,
			&i.LocksRemoved,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const workQueueCompleteDirect = `-- name: WorkQueueCompleteDirect :exec
WITH updated AS (
  UPDATE public.work_queue w
  SET
    claimed_by     = -1,
    claimed_at     = NULL,
    heartbeated_at = NOW(),
    needs_run      = FALSE,
    runnable_at    = NOW(),
    tries          = 0
  WHERE w.id         = $2::BIGINT
    AND w.claimed_by = $1
  RETURNING id
)
DELETE FROM public.signal_locks sl
USING updated u
WHERE sl.work_id    = u.id
  AND sl.claimed_by = $1
`

type WorkQueueCompleteParams struct {
	WorkerID int64 `json:"worker_id"`
	ID       int64 `json:"id"`
}

func (q *Queries) WorkQueueCompleteDirect(ctx context.Context, arg WorkQueueCompleteParams) error {
	_, err := q.db.Exec(ctx, workQueueCompleteDirect, arg.WorkerID, arg.ID)
	return err
}

const workQueueFailDirect = `-- name: WorkQueueFailDirect :exec
WITH params AS (
  SELECT
    NOW()                                         AS v_now,
    (SELECT value::interval
       FROM public.settings
      WHERE key = 'work_fail_requeue_ttl')        AS requeue_ttl,
    (SELECT value::int
       FROM public.settings
      WHERE key = 'max_retries')                  AS max_retries
),
old AS (
  SELECT w.tries
  FROM public.work_queue w
  WHERE w.id         = $1::BIGINT
    AND w.claimed_by = $2
),
updated AS (
  UPDATE public.work_queue w
  SET
    claimed_by     = -1,
    claimed_at     = NULL,
    heartbeated_at = (SELECT v_now FROM params),
    tries =
      CASE
        WHEN o.tries IS NULL THEN 1
        ELSE o.tries + 1
      END,
    runnable_at =
      CASE
        WHEN o.tries + 1 <= (SELECT max_retries FROM params)
          THEN (SELECT v_now FROM params) + (SELECT requeue_ttl FROM params)
        ELSE w.runnable_at
      END,
    needs_run =
      CASE
        WHEN o.tries + 1 <= (SELECT max_retries FROM params) THEN TRUE
        ELSE FALSE
      END
  FROM old o
  WHERE w.id         = $1::BIGINT
    AND w.claimed_by = $2
)
DELETE FROM public.signal_locks sl
WHERE sl.work_id    = $1::BIGINT
  AND sl.claimed_by = $2
`

type WorkQueueFailParams struct {
	ID       int64 `json:"id"`
	WorkerID int64 `json:"worker_id"`
}

func (q *Queries) WorkQueueFailDirect(ctx context.Context, arg WorkQueueFailParams) error {
	_, err := q.db.Exec(ctx, workQueueFailDirect, arg.ID, arg.WorkerID)
	return err
}

const workQueueGC = `-- name: WorkQueueGC :one
WITH doomed AS (
  SELECT w.id
  FROM public.work_queue AS w
  WHERE w.claimed_by = -1
    AND NOT w.needs_run
    AND w.runnable_at < $1
  ORDER BY w.runnable_at
  LIMIT $2
  FOR UPDATE SKIP LOCKED
),
del_wq AS (
  DELETE FROM public.work_queue AS w
  USING doomed AS d
  WHERE w.id = d.id
  RETURNING 1
)
SELECT COALESCE(COUNT(*), 0)::int AS deleted
FROM del_wq
`

type WorkQueueGCParams struct {
	Cutoff  time.Time `json:"cutoff"`
	Maxrows int32     `json:"maxrows"`
}

func (q *Queries) WorkQueueGC(ctx context.Context, arg WorkQueueGCParams) (int32, error) {
	row := q.db.QueryRow(ctx, workQueueGC, arg.Cutoff, arg.Maxrows)
	var deleted int32
	err := row.Scan(&deleted)
	return deleted, err
}

const workQueueGlobalLock = `-- name: WorkQueueGlobalLock :exec
SELECT pg_advisory_xact_lock(hashtext('work_queue_global')::bigint)
`

func (q *Queries) WorkQueueGlobalLock(ctx context.Context) error {
	_, err := q.db.Exec(ctx, workQueueGlobalLock)
	return err
}

const workQueueHeartbeatDirect = `-- name: WorkQueueHeartbeatDirect :exec
WITH params AS (
  SELECT
    NOW() AS v_now,
    (SELECT value::interval
       FROM public.settings
      WHERE key = 'lock_ttl') AS lock_ttl
)
UPDATE public.work_queue w
SET heartbeated_at = p.v_now
FROM params p
WHERE w.id            = ANY($1::BIGINT[])
  AND w.claimed_by    = $2
  AND w.heartbeated_at >= p.v_now - p.lock_ttl
`

type WorkQueueHeartbeatParams struct {
	Ids      []int64 `json:"ids"`
	WorkerID int64   `json:"worker_id"`
}

// 1) heart-beat the work_queue
func (q *Queries) WorkQueueHeartbeatDirect(ctx context.Context, arg WorkQueueHeartbeatParams) error {
	_, err := q.db.Exec(ctx, workQueueHeartbeatDirect, arg.Ids, arg.WorkerID)
	return err
}

const workQueueSummary = `-- name: WorkQueueSummary :many
SELECT count(*) AS count, signal, action
FROM work_queue
WHERE needs_run = true AND runnable_at <= now()
GROUP BY signal, action
ORDER BY signal, action
`

type WorkQueueSummaryRow struct {
	Count  int64      `json:"count"`
	Signal SignalEnum `json:"signal"`
	Action ActionEnum `json:"action"`
}

func (q *Queries) WorkQueueSummary(ctx context.Context) ([]WorkQueueSummaryRow, error) {
	rows, err := q.db.Query(ctx, workQueueSummary)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkQueueSummaryRow
	for rows.Next() {
		var i WorkQueueSummaryRow
		if err := rows.Scan(&i.Count, &i.Signal, &i.Action); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
