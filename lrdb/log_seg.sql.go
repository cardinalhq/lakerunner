// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: log_seg.sql

package lrdb

import (
	"context"

	"github.com/google/uuid"
)

const getLabelNameMaps = `-- name: GetLabelNameMaps :many
SELECT
    segment_id,
    label_name_map
FROM log_seg
WHERE organization_id = $1
  AND dateint = $2
  AND segment_id = ANY($3::BIGINT[])
  AND label_name_map IS NOT NULL
`

type GetLabelNameMapsParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	SegmentIds     []int64   `json:"segment_ids"`
}

type GetLabelNameMapsRow struct {
	SegmentID    int64  `json:"segment_id"`
	LabelNameMap []byte `json:"label_name_map"`
}

func (q *Queries) GetLabelNameMaps(ctx context.Context, arg GetLabelNameMapsParams) ([]GetLabelNameMapsRow, error) {
	rows, err := q.db.Query(ctx, getLabelNameMaps, arg.OrganizationID, arg.Dateint, arg.SegmentIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLabelNameMapsRow
	for rows.Next() {
		var i GetLabelNameMapsRow
		if err := rows.Scan(&i.SegmentID, &i.LabelNameMap); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogSeg = `-- name: GetLogSeg :one
SELECT organization_id, dateint, segment_id, instance_num, fingerprints, record_count, file_size, ingest_dateint, ts_range, created_by, created_at, compacted, published, label_name_map, stream_ids, sort_version
FROM log_seg
WHERE organization_id = $1
  AND dateint = $2
  AND segment_id = $3
  AND instance_num = $4
`

type GetLogSegParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	SegmentID      int64     `json:"segment_id"`
	InstanceNum    int16     `json:"instance_num"`
}

func (q *Queries) GetLogSeg(ctx context.Context, arg GetLogSegParams) (LogSeg, error) {
	row := q.db.QueryRow(ctx, getLogSeg,
		arg.OrganizationID,
		arg.Dateint,
		arg.SegmentID,
		arg.InstanceNum,
	)
	var i LogSeg
	err := row.Scan(
		&i.OrganizationID,
		&i.Dateint,
		&i.SegmentID,
		&i.InstanceNum,
		&i.Fingerprints,
		&i.RecordCount,
		&i.FileSize,
		&i.IngestDateint,
		&i.TsRange,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.Compacted,
		&i.Published,
		&i.LabelNameMap,
		&i.StreamIds,
		&i.SortVersion,
	)
	return i, err
}

const listLogSegmentsForQuery = `-- name: ListLogSegmentsForQuery :many
SELECT
    t.fp::bigint                    AS fingerprint,
    s.instance_num,
    s.segment_id,
    lower(s.ts_range)::bigint        AS start_ts,
    (upper(s.ts_range) - 1)::bigint  AS end_ts
FROM log_seg AS s
         CROSS JOIN LATERAL
    unnest(s.fingerprints) AS t(fp)
WHERE
    s.organization_id = $1
  AND s.dateint       = $2
  AND s.published     = true
  AND s.fingerprints && $3::BIGINT[]
  AND t.fp            = ANY($3::BIGINT[])
  AND ts_range && int8range($4, $5, '[)')
`

type ListLogSegmentsForQueryParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	Fingerprints   []int64   `json:"fingerprints"`
	S              int64     `json:"s"`
	E              int64     `json:"e"`
}

type ListLogSegmentsForQueryRow struct {
	Fingerprint int64 `json:"fingerprint"`
	InstanceNum int16 `json:"instance_num"`
	SegmentID   int64 `json:"segment_id"`
	StartTs     int64 `json:"start_ts"`
	EndTs       int64 `json:"end_ts"`
}

func (q *Queries) ListLogSegmentsForQuery(ctx context.Context, arg ListLogSegmentsForQueryParams) ([]ListLogSegmentsForQueryRow, error) {
	rows, err := q.db.Query(ctx, listLogSegmentsForQuery,
		arg.OrganizationID,
		arg.Dateint,
		arg.Fingerprints,
		arg.S,
		arg.E,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLogSegmentsForQueryRow
	for rows.Next() {
		var i ListLogSegmentsForQueryRow
		if err := rows.Scan(
			&i.Fingerprint,
			&i.InstanceNum,
			&i.SegmentID,
			&i.StartTs,
			&i.EndTs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLogStreamIDs = `-- name: ListLogStreamIDs :many
SELECT DISTINCT unnest(stream_ids)::text AS stream_id
FROM log_seg
WHERE organization_id = $1
  AND dateint >= $2
  AND dateint <= $3
  AND ts_range && int8range($4, $5, '[)')
  AND published = true
  AND stream_ids IS NOT NULL
`

type ListLogStreamIDsParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	StartDateint   int32     `json:"start_dateint"`
	EndDateint     int32     `json:"end_dateint"`
	StartTs        int64     `json:"start_ts"`
	EndTs          int64     `json:"end_ts"`
}

// Returns distinct stream IDs for an organization within a time range.
// Used by /api/v1/logs/series endpoint (Loki-compatible).
func (q *Queries) ListLogStreamIDs(ctx context.Context, arg ListLogStreamIDsParams) ([]string, error) {
	rows, err := q.db.Query(ctx, listLogStreamIDs,
		arg.OrganizationID,
		arg.StartDateint,
		arg.EndDateint,
		arg.StartTs,
		arg.EndTs,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var stream_id string
		if err := rows.Scan(&stream_id); err != nil {
			return nil, err
		}
		items = append(items, stream_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markLogSegsCompactedByKeys = `-- name: MarkLogSegsCompactedByKeys :exec
UPDATE log_seg
SET compacted = true
WHERE organization_id = $1
  AND dateint         = $2
  AND instance_num    = $3
  AND segment_id      = ANY($4::bigint[])
  AND compacted       = false
`

type MarkLogSegsCompactedByKeysParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	InstanceNum    int16     `json:"instance_num"`
	SegmentIds     []int64   `json:"segment_ids"`
}

func (q *Queries) MarkLogSegsCompactedByKeys(ctx context.Context, arg MarkLogSegsCompactedByKeysParams) error {
	_, err := q.db.Exec(ctx, markLogSegsCompactedByKeys,
		arg.OrganizationID,
		arg.Dateint,
		arg.InstanceNum,
		arg.SegmentIds,
	)
	return err
}

const insertLogSegmentDirect = `-- name: insertLogSegmentDirect :exec
INSERT INTO log_seg (
  organization_id,
  dateint,
  segment_id,
  instance_num,
  ts_range,
  record_count,
  file_size,
  created_by,
  fingerprints,
  published,
  compacted,
  label_name_map,
  stream_ids,
  sort_version
)
VALUES (
  $1,
  $2,
  $3,
  $4,
  int8range($5, $6, '[)'),
  $7,
  $8,
  $9,
  $10::bigint[],
  $11,
  $12,
  $13,
  $14::text[],
  $15
)
`

type InsertLogSegmentParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	SegmentID      int64     `json:"segment_id"`
	InstanceNum    int16     `json:"instance_num"`
	StartTs        int64     `json:"start_ts"`
	EndTs          int64     `json:"end_ts"`
	RecordCount    int64     `json:"record_count"`
	FileSize       int64     `json:"file_size"`
	CreatedBy      CreatedBy `json:"created_by"`
	Fingerprints   []int64   `json:"fingerprints"`
	Published      bool      `json:"published"`
	Compacted      bool      `json:"compacted"`
	LabelNameMap   []byte    `json:"label_name_map"`
	StreamIds      []string  `json:"stream_ids"`
	SortVersion    int16     `json:"sort_version"`
}

func (q *Queries) insertLogSegmentDirect(ctx context.Context, arg InsertLogSegmentParams) error {
	_, err := q.db.Exec(ctx, insertLogSegmentDirect,
		arg.OrganizationID,
		arg.Dateint,
		arg.SegmentID,
		arg.InstanceNum,
		arg.StartTs,
		arg.EndTs,
		arg.RecordCount,
		arg.FileSize,
		arg.CreatedBy,
		arg.Fingerprints,
		arg.Published,
		arg.Compacted,
		arg.LabelNameMap,
		arg.StreamIds,
		arg.SortVersion,
	)
	return err
}

const markLogSegsCompactedUnpublishedByKeys = `-- name: markLogSegsCompactedUnpublishedByKeys :exec
UPDATE log_seg
SET compacted = true, published = false
WHERE organization_id = $1
  AND dateint         = $2
  AND instance_num    = $3
  AND segment_id      = ANY($4::bigint[])
  AND compacted       = false
`

type markLogSegsCompactedUnpublishedByKeysParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	InstanceNum    int16     `json:"instance_num"`
	SegmentIds     []int64   `json:"segment_ids"`
}

func (q *Queries) markLogSegsCompactedUnpublishedByKeys(ctx context.Context, arg markLogSegsCompactedUnpublishedByKeysParams) error {
	_, err := q.db.Exec(ctx, markLogSegsCompactedUnpublishedByKeys,
		arg.OrganizationID,
		arg.Dateint,
		arg.InstanceNum,
		arg.SegmentIds,
	)
	return err
}
