// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: log_seg.sql

package lrdb

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const compactLogSegments = `-- name: CompactLogSegments :exec
WITH
  all_fp AS (
    SELECT unnest(fingerprints) AS fp
      FROM log_seg
     WHERE organization_id = $1
       AND dateint        = $2
       AND instance_num   = $5
       AND segment_id     = ANY($12::bigint[])
  ),
  fingerprint_array AS (
    SELECT coalesce(
      array_agg(DISTINCT fp ORDER BY fp),
      '{}'::bigint[]
    ) AS fingerprints
    FROM all_fp
  ),
  deleted_seg AS (
    DELETE FROM log_seg
     WHERE organization_id = $1
       AND dateint        = $2
       AND instance_num   = $5
       AND segment_id     = ANY($12::bigint[])
  )
INSERT INTO log_seg (
  organization_id,
  dateint,
  ingest_dateint,
  segment_id,
  instance_num,
  slot_id,
  record_count,
  file_size,
  ts_range,
  created_by,
  fingerprints
)
SELECT
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  int8range($9, $10, '[)'),
  $11,
  fa.fingerprints
FROM fingerprint_array AS fa
`

type CompactLogSegmentsParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	IngestDateint  int32     `json:"ingest_dateint"`
	NewSegmentID   int64     `json:"new_segment_id"`
	InstanceNum    int16     `json:"instance_num"`
	SlotID         int32     `json:"slot_id"`
	NewRecordCount int64     `json:"new_record_count"`
	NewFileSize    int64     `json:"new_file_size"`
	NewStartTs     int64     `json:"new_start_ts"`
	NewEndTs       int64     `json:"new_end_ts"`
	CreatedBy      CreatedBy `json:"created_by"`
	OldSegmentIds  []int64   `json:"old_segment_ids"`
}

func (q *Queries) CompactLogSegments(ctx context.Context, arg CompactLogSegmentsParams) error {
	_, err := q.db.Exec(ctx, compactLogSegments,
		arg.OrganizationID,
		arg.Dateint,
		arg.IngestDateint,
		arg.NewSegmentID,
		arg.InstanceNum,
		arg.SlotID,
		arg.NewRecordCount,
		arg.NewFileSize,
		arg.NewStartTs,
		arg.NewEndTs,
		arg.CreatedBy,
		arg.OldSegmentIds,
	)
	return err
}

const getLogSegmentsForCompaction = `-- name: GetLogSegmentsForCompaction :many
SELECT
  segment_id,
  lower(ts_range)::bigint AS start_ts,
  upper(ts_range)::bigint AS end_ts,
  file_size,
  record_count,
  ingest_dateint,
  created_at,
  slot_id
FROM log_seg
WHERE organization_id = $1
  AND dateint         = $2
  AND instance_num    = $3
  AND slot_id         = $4
  AND file_size > 0
  AND record_count > 0
  AND file_size <= $5
  AND (created_at, segment_id) > ($6, $7::bigint)
  AND ts_range && int8range($8, $9, '[)')
ORDER BY created_at, segment_id
LIMIT $10
`

type GetLogSegmentsForCompactionParams struct {
	OrganizationID  uuid.UUID `json:"organization_id"`
	Dateint         int32     `json:"dateint"`
	InstanceNum     int16     `json:"instance_num"`
	SlotID          int32     `json:"slot_id"`
	MaxFileSize     int64     `json:"max_file_size"`
	CursorCreatedAt time.Time `json:"cursor_created_at"`
	CursorSegmentID int64     `json:"cursor_segment_id"`
	HourStartTs     int64     `json:"hour_start_ts"`
	HourEndTs       int64     `json:"hour_end_ts"`
	Maxrows         int32     `json:"maxrows"`
}

type GetLogSegmentsForCompactionRow struct {
	SegmentID     int64     `json:"segment_id"`
	StartTs       int64     `json:"start_ts"`
	EndTs         int64     `json:"end_ts"`
	FileSize      int64     `json:"file_size"`
	RecordCount   int64     `json:"record_count"`
	IngestDateint int32     `json:"ingest_dateint"`
	CreatedAt     time.Time `json:"created_at"`
	SlotID        int32     `json:"slot_id"`
}

func (q *Queries) GetLogSegmentsForCompaction(ctx context.Context, arg GetLogSegmentsForCompactionParams) ([]GetLogSegmentsForCompactionRow, error) {
	rows, err := q.db.Query(ctx, getLogSegmentsForCompaction,
		arg.OrganizationID,
		arg.Dateint,
		arg.InstanceNum,
		arg.SlotID,
		arg.MaxFileSize,
		arg.CursorCreatedAt,
		arg.CursorSegmentID,
		arg.HourStartTs,
		arg.HourEndTs,
		arg.Maxrows,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLogSegmentsForCompactionRow
	for rows.Next() {
		var i GetLogSegmentsForCompactionRow
		if err := rows.Scan(
			&i.SegmentID,
			&i.StartTs,
			&i.EndTs,
			&i.FileSize,
			&i.RecordCount,
			&i.IngestDateint,
			&i.CreatedAt,
			&i.SlotID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertLogSegmentDirect = `-- name: InsertLogSegmentDirect :exec
INSERT INTO log_seg (
  organization_id,
  dateint,
  ingest_dateint,
  segment_id,
  instance_num,
  slot_id,
  ts_range,
  record_count,
  file_size,
  created_by,
  fingerprints
)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  int8range($7, $8, '[)'),
  $9,
  $10,
  $11,
  $12::bigint[]
)
`

type InsertLogSegmentParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	IngestDateint  int32     `json:"ingest_dateint"`
	SegmentID      int64     `json:"segment_id"`
	InstanceNum    int16     `json:"instance_num"`
	SlotID         int32     `json:"slot_id"`
	StartTs        int64     `json:"start_ts"`
	EndTs          int64     `json:"end_ts"`
	RecordCount    int64     `json:"record_count"`
	FileSize       int64     `json:"file_size"`
	CreatedBy      CreatedBy `json:"created_by"`
	Fingerprints   []int64   `json:"fingerprints"`
}

func (q *Queries) InsertLogSegmentDirect(ctx context.Context, arg InsertLogSegmentParams) error {
	_, err := q.db.Exec(ctx, insertLogSegmentDirect,
		arg.OrganizationID,
		arg.Dateint,
		arg.IngestDateint,
		arg.SegmentID,
		arg.InstanceNum,
		arg.SlotID,
		arg.StartTs,
		arg.EndTs,
		arg.RecordCount,
		arg.FileSize,
		arg.CreatedBy,
		arg.Fingerprints,
	)
	return err
}

const listLogSegmentsForQuery = `-- name: ListLogSegmentsForQuery :many
SELECT
    t.fp::bigint                    AS fingerprint,
    s.instance_num,
    s.segment_id,
    lower(s.ts_range)::bigint        AS start_ts,
    (upper(s.ts_range) - 1)::bigint  AS end_ts
FROM log_seg AS s
         CROSS JOIN LATERAL
    unnest(s.fingerprints) AS t(fp)
WHERE
    s.organization_id = $1
  AND s.dateint      = $2
  AND s.fingerprints && $3::BIGINT[]
  AND t.fp           = ANY($3::BIGINT[])
  AND ts_range && int8range($4, $5, '[)')
`

type ListLogSegmentsForQueryParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	Fingerprints   []int64   `json:"fingerprints"`
	S              int64     `json:"s"`
	E              int64     `json:"e"`
}

type ListLogSegmentsForQueryRow struct {
	Fingerprint int64 `json:"fingerprint"`
	InstanceNum int16 `json:"instance_num"`
	SegmentID   int64 `json:"segment_id"`
	StartTs     int64 `json:"start_ts"`
	EndTs       int64 `json:"end_ts"`
}

func (q *Queries) ListLogSegmentsForQuery(ctx context.Context, arg ListLogSegmentsForQueryParams) ([]ListLogSegmentsForQueryRow, error) {
	rows, err := q.db.Query(ctx, listLogSegmentsForQuery,
		arg.OrganizationID,
		arg.Dateint,
		arg.Fingerprints,
		arg.S,
		arg.E,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLogSegmentsForQueryRow
	for rows.Next() {
		var i ListLogSegmentsForQueryRow
		if err := rows.Scan(
			&i.Fingerprint,
			&i.InstanceNum,
			&i.SegmentID,
			&i.StartTs,
			&i.EndTs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
