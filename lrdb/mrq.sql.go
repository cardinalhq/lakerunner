// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: mrq.sql

package lrdb

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const mrqClaimBundle = `-- name: MrqClaimBundle :exec
UPDATE public.metric_rollup_queue
SET claimed_by = $1, claimed_at = now(), heartbeated_at = now()
WHERE id = ANY($2::bigint[])
`

type MrqClaimBundleParams struct {
	WorkerID int64   `json:"worker_id"`
	Ids      []int64 `json:"ids"`
}

func (q *Queries) MrqClaimBundle(ctx context.Context, arg MrqClaimBundleParams) error {
	_, err := q.db.Exec(ctx, mrqClaimBundle, arg.WorkerID, arg.Ids)
	return err
}

const mrqCompleteDelete = `-- name: MrqCompleteDelete :exec
DELETE FROM public.metric_rollup_queue
WHERE claimed_by = $1 AND id = ANY($2::bigint[])
`

type MrqCompleteDeleteParams struct {
	WorkerID int64   `json:"worker_id"`
	Ids      []int64 `json:"ids"`
}

func (q *Queries) MrqCompleteDelete(ctx context.Context, arg MrqCompleteDeleteParams) error {
	_, err := q.db.Exec(ctx, mrqCompleteDelete, arg.WorkerID, arg.Ids)
	return err
}

const mrqDeferKey = `-- name: MrqDeferKey :exec
UPDATE public.metric_rollup_queue
SET eligible_at = now() + $1::interval
WHERE claimed_by = -1
  AND organization_id = $2
  AND dateint        = $3
  AND frequency_ms   = $4
  AND instance_num   = $5
  AND slot_id        = $6
  AND slot_count     = $7
  AND rollup_group   = $8
`

type MrqDeferKeyParams struct {
	Push           time.Duration `json:"push"`
	OrganizationID uuid.UUID     `json:"organization_id"`
	Dateint        int32         `json:"dateint"`
	FrequencyMs    int64         `json:"frequency_ms"`
	InstanceNum    int16         `json:"instance_num"`
	SlotID         int32         `json:"slot_id"`
	SlotCount      int32         `json:"slot_count"`
	RollupGroup    int64         `json:"rollup_group"`
}

func (q *Queries) MrqDeferKey(ctx context.Context, arg MrqDeferKeyParams) error {
	_, err := q.db.Exec(ctx, mrqDeferKey,
		arg.Push,
		arg.OrganizationID,
		arg.Dateint,
		arg.FrequencyMs,
		arg.InstanceNum,
		arg.SlotID,
		arg.SlotCount,
		arg.RollupGroup,
	)
	return err
}

const mrqFetchCandidates = `-- name: MrqFetchCandidates :many
SELECT id, segment_id, record_count, window_close_ts, queue_ts
FROM public.metric_rollup_queue
WHERE claimed_by = -1
  AND eligible_at <= now()
  AND organization_id = $1
  AND dateint        = $2
  AND frequency_ms   = $3
  AND instance_num   = $4
  AND slot_id        = $5
  AND slot_count     = $6
  AND rollup_group   = $7
ORDER BY window_close_ts ASC, queue_ts ASC, id ASC
FOR UPDATE SKIP LOCKED
LIMIT $8
`

type MrqFetchCandidatesParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	FrequencyMs    int64     `json:"frequency_ms"`
	InstanceNum    int16     `json:"instance_num"`
	SlotID         int32     `json:"slot_id"`
	SlotCount      int32     `json:"slot_count"`
	RollupGroup    int64     `json:"rollup_group"`
	MaxRows        int32     `json:"max_rows"`
}

type MrqFetchCandidatesRow struct {
	ID            int64     `json:"id"`
	SegmentID     int64     `json:"segment_id"`
	RecordCount   int64     `json:"record_count"`
	WindowCloseTs time.Time `json:"window_close_ts"`
	QueueTs       time.Time `json:"queue_ts"`
}

func (q *Queries) MrqFetchCandidates(ctx context.Context, arg MrqFetchCandidatesParams) ([]MrqFetchCandidatesRow, error) {
	rows, err := q.db.Query(ctx, mrqFetchCandidates,
		arg.OrganizationID,
		arg.Dateint,
		arg.FrequencyMs,
		arg.InstanceNum,
		arg.SlotID,
		arg.SlotCount,
		arg.RollupGroup,
		arg.MaxRows,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MrqFetchCandidatesRow
	for rows.Next() {
		var i MrqFetchCandidatesRow
		if err := rows.Scan(
			&i.ID,
			&i.SegmentID,
			&i.RecordCount,
			&i.WindowCloseTs,
			&i.QueueTs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mrqHeartbeat = `-- name: MrqHeartbeat :exec
UPDATE public.metric_rollup_queue
SET heartbeated_at = now()
WHERE claimed_by = $1 AND id = ANY($2::bigint[])
`

type MrqHeartbeatParams struct {
	WorkerID int64   `json:"worker_id"`
	Ids      []int64 `json:"ids"`
}

func (q *Queries) MrqHeartbeat(ctx context.Context, arg MrqHeartbeatParams) error {
	_, err := q.db.Exec(ctx, mrqHeartbeat, arg.WorkerID, arg.Ids)
	return err
}

const mrqPickHead = `-- name: MrqPickHead :one
SELECT id, organization_id, dateint, frequency_ms, instance_num,
       slot_id, slot_count, rollup_group, segment_id, record_count, window_close_ts, queue_ts
FROM public.metric_rollup_queue
WHERE claimed_by = -1
  AND eligible_at <= now()
ORDER BY priority ASC, eligible_at ASC, window_close_ts ASC, queue_ts ASC
FOR UPDATE SKIP LOCKED
LIMIT 1
`

type MrqPickHeadRow struct {
	ID             int64     `json:"id"`
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	FrequencyMs    int64     `json:"frequency_ms"`
	InstanceNum    int16     `json:"instance_num"`
	SlotID         int32     `json:"slot_id"`
	SlotCount      int32     `json:"slot_count"`
	RollupGroup    int64     `json:"rollup_group"`
	SegmentID      int64     `json:"segment_id"`
	RecordCount    int64     `json:"record_count"`
	WindowCloseTs  time.Time `json:"window_close_ts"`
	QueueTs        time.Time `json:"queue_ts"`
}

func (q *Queries) MrqPickHead(ctx context.Context) (MrqPickHeadRow, error) {
	row := q.db.QueryRow(ctx, mrqPickHead)
	var i MrqPickHeadRow
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Dateint,
		&i.FrequencyMs,
		&i.InstanceNum,
		&i.SlotID,
		&i.SlotCount,
		&i.RollupGroup,
		&i.SegmentID,
		&i.RecordCount,
		&i.WindowCloseTs,
		&i.QueueTs,
	)
	return i, err
}

const mrqReclaimTimeouts = `-- name: MrqReclaimTimeouts :execrows
WITH stale AS (
  SELECT id
  FROM public.metric_rollup_queue
  WHERE claimed_by <> -1
    AND heartbeated_at < (now() - $1::interval)
  LIMIT $2
)
UPDATE public.metric_rollup_queue q
SET claimed_by = -1, claimed_at = NULL, heartbeated_at = NULL, tries = q.tries + 1
FROM stale s
WHERE q.id = s.id
`

type MrqReclaimTimeoutsParams struct {
	MaxAge  time.Duration `json:"max_age"`
	MaxRows int32         `json:"max_rows"`
}

func (q *Queries) MrqReclaimTimeouts(ctx context.Context, arg MrqReclaimTimeoutsParams) (int64, error) {
	result, err := q.db.Exec(ctx, mrqReclaimTimeouts, arg.MaxAge, arg.MaxRows)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
