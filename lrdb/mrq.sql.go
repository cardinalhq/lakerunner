// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: mrq.sql

package lrdb

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const mrqClaimBatch = `-- name: MrqClaimBatch :many
WITH candidates AS (
  SELECT id, organization_id, dateint, frequency_ms, instance_num,
         slot_id, slot_count, rollup_group, segment_id, record_count, queue_ts
  FROM public.metric_rollup_queue
  WHERE claimed_by = -1
    AND eligible_at <= now()
  ORDER BY priority ASC, eligible_at ASC, queue_ts ASC
  FOR UPDATE SKIP LOCKED
  LIMIT $3
)
UPDATE public.metric_rollup_queue q
SET claimed_by = $1, claimed_at = $2::timestamptz, heartbeated_at = $2::timestamptz
FROM candidates c
WHERE q.id = c.id
RETURNING c.id, c.organization_id, c.dateint, c.frequency_ms, c.instance_num,
          c.slot_id, c.slot_count, c.rollup_group, c.segment_id, c.record_count, c.queue_ts
`

type MrqClaimBatchParams struct {
	WorkerID   int64     `json:"worker_id"`
	Now        time.Time `json:"now"`
	BatchLimit int32     `json:"batch_limit"`
}

type MrqClaimBatchRow struct {
	ID             int64     `json:"id"`
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	FrequencyMs    int32     `json:"frequency_ms"`
	InstanceNum    int16     `json:"instance_num"`
	SlotID         int32     `json:"slot_id"`
	SlotCount      int32     `json:"slot_count"`
	RollupGroup    int64     `json:"rollup_group"`
	SegmentID      int64     `json:"segment_id"`
	RecordCount    int64     `json:"record_count"`
	QueueTs        time.Time `json:"queue_ts"`
}

func (q *Queries) MrqClaimBatch(ctx context.Context, arg MrqClaimBatchParams) ([]MrqClaimBatchRow, error) {
	rows, err := q.db.Query(ctx, mrqClaimBatch, arg.WorkerID, arg.Now, arg.BatchLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MrqClaimBatchRow
	for rows.Next() {
		var i MrqClaimBatchRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Dateint,
			&i.FrequencyMs,
			&i.InstanceNum,
			&i.SlotID,
			&i.SlotCount,
			&i.RollupGroup,
			&i.SegmentID,
			&i.RecordCount,
			&i.QueueTs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mrqClaimBundle = `-- name: MrqClaimBundle :exec
UPDATE public.metric_rollup_queue
SET claimed_by = $1, claimed_at = now(), heartbeated_at = now()
WHERE id = ANY($2::bigint[])
`

type MrqClaimBundleParams struct {
	WorkerID int64   `json:"worker_id"`
	Ids      []int64 `json:"ids"`
}

func (q *Queries) MrqClaimBundle(ctx context.Context, arg MrqClaimBundleParams) error {
	_, err := q.db.Exec(ctx, mrqClaimBundle, arg.WorkerID, arg.Ids)
	return err
}

const mrqClaimSingleRow = `-- name: MrqClaimSingleRow :one
WITH candidate AS (
  SELECT id, organization_id, dateint, frequency_ms, instance_num,
         slot_id, slot_count, rollup_group, segment_id, record_count, queue_ts
  FROM public.metric_rollup_queue
  WHERE claimed_by = -1
  ORDER BY priority ASC, queue_ts ASC
  FOR UPDATE SKIP LOCKED
  LIMIT 1
)
UPDATE public.metric_rollup_queue q
SET claimed_by = $1, claimed_at = $2::timestamptz, heartbeated_at = $2::timestamptz
FROM candidate c
WHERE q.id = c.id
RETURNING c.id, c.organization_id, c.dateint, c.frequency_ms, c.instance_num,
          c.slot_id, c.slot_count, c.rollup_group, c.segment_id, c.record_count, c.queue_ts
`

type MrqClaimSingleRowParams struct {
	WorkerID int64     `json:"worker_id"`
	Now      time.Time `json:"now"`
}

type MrqClaimSingleRowRow struct {
	ID             int64     `json:"id"`
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	FrequencyMs    int32     `json:"frequency_ms"`
	InstanceNum    int16     `json:"instance_num"`
	SlotID         int32     `json:"slot_id"`
	SlotCount      int32     `json:"slot_count"`
	RollupGroup    int64     `json:"rollup_group"`
	SegmentID      int64     `json:"segment_id"`
	RecordCount    int64     `json:"record_count"`
	QueueTs        time.Time `json:"queue_ts"`
}

func (q *Queries) MrqClaimSingleRow(ctx context.Context, arg MrqClaimSingleRowParams) (MrqClaimSingleRowRow, error) {
	row := q.db.QueryRow(ctx, mrqClaimSingleRow, arg.WorkerID, arg.Now)
	var i MrqClaimSingleRowRow
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Dateint,
		&i.FrequencyMs,
		&i.InstanceNum,
		&i.SlotID,
		&i.SlotCount,
		&i.RollupGroup,
		&i.SegmentID,
		&i.RecordCount,
		&i.QueueTs,
	)
	return i, err
}

const mrqCompleteDelete = `-- name: MrqCompleteDelete :exec
DELETE FROM public.metric_rollup_queue
WHERE claimed_by = $1 AND id = ANY($2::bigint[])
`

type MrqCompleteDeleteParams struct {
	WorkerID int64   `json:"worker_id"`
	Ids      []int64 `json:"ids"`
}

func (q *Queries) MrqCompleteDelete(ctx context.Context, arg MrqCompleteDeleteParams) error {
	_, err := q.db.Exec(ctx, mrqCompleteDelete, arg.WorkerID, arg.Ids)
	return err
}

const mrqDeferItems = `-- name: MrqDeferItems :exec
UPDATE public.metric_rollup_queue
SET eligible_at = now() + $1::interval
WHERE claimed_by = -1
  AND id = ANY($2::bigint[])
`

type MrqDeferItemsParams struct {
	Push time.Duration `json:"push"`
	Ids  []int64       `json:"ids"`
}

func (q *Queries) MrqDeferItems(ctx context.Context, arg MrqDeferItemsParams) error {
	_, err := q.db.Exec(ctx, mrqDeferItems, arg.Push, arg.Ids)
	return err
}

const mrqFetchCandidates = `-- name: MrqFetchCandidates :many
SELECT id, organization_id, dateint, frequency_ms, instance_num,
       slot_id, slot_count, rollup_group, segment_id, record_count, queue_ts
FROM public.metric_rollup_queue
WHERE claimed_by = -1
  AND eligible_at <= now()
  AND organization_id = $1
  AND dateint        = $2
  AND frequency_ms   = $3
  AND instance_num   = $4
  AND slot_id        = $5
  AND slot_count     = $6
  AND rollup_group   = $7
ORDER BY queue_ts ASC, id ASC
FOR UPDATE
LIMIT $8
`

type MrqFetchCandidatesParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	FrequencyMs    int32     `json:"frequency_ms"`
	InstanceNum    int16     `json:"instance_num"`
	SlotID         int32     `json:"slot_id"`
	SlotCount      int32     `json:"slot_count"`
	RollupGroup    int64     `json:"rollup_group"`
	MaxRows        int32     `json:"max_rows"`
}

type MrqFetchCandidatesRow struct {
	ID             int64     `json:"id"`
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	FrequencyMs    int32     `json:"frequency_ms"`
	InstanceNum    int16     `json:"instance_num"`
	SlotID         int32     `json:"slot_id"`
	SlotCount      int32     `json:"slot_count"`
	RollupGroup    int64     `json:"rollup_group"`
	SegmentID      int64     `json:"segment_id"`
	RecordCount    int64     `json:"record_count"`
	QueueTs        time.Time `json:"queue_ts"`
}

func (q *Queries) MrqFetchCandidates(ctx context.Context, arg MrqFetchCandidatesParams) ([]MrqFetchCandidatesRow, error) {
	rows, err := q.db.Query(ctx, mrqFetchCandidates,
		arg.OrganizationID,
		arg.Dateint,
		arg.FrequencyMs,
		arg.InstanceNum,
		arg.SlotID,
		arg.SlotCount,
		arg.RollupGroup,
		arg.MaxRows,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MrqFetchCandidatesRow
	for rows.Next() {
		var i MrqFetchCandidatesRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Dateint,
			&i.FrequencyMs,
			&i.InstanceNum,
			&i.SlotID,
			&i.SlotCount,
			&i.RollupGroup,
			&i.SegmentID,
			&i.RecordCount,
			&i.QueueTs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mrqHeartbeat = `-- name: MrqHeartbeat :execrows
UPDATE public.metric_rollup_queue
SET heartbeated_at = now()
WHERE claimed_by = $1 AND id = ANY($2::bigint[])
`

type MrqHeartbeatParams struct {
	WorkerID int64   `json:"worker_id"`
	Ids      []int64 `json:"ids"`
}

func (q *Queries) MrqHeartbeat(ctx context.Context, arg MrqHeartbeatParams) (int64, error) {
	result, err := q.db.Exec(ctx, mrqHeartbeat, arg.WorkerID, arg.Ids)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const mrqPickHead = `-- name: MrqPickHead :one
SELECT id, organization_id, dateint, frequency_ms, instance_num,
       slot_id, slot_count, rollup_group, segment_id, record_count, queue_ts
FROM public.metric_rollup_queue
WHERE claimed_by = -1
  AND eligible_at <= now()
ORDER BY priority ASC, eligible_at ASC, queue_ts ASC
FOR UPDATE
LIMIT 1
`

type MrqPickHeadRow struct {
	ID             int64     `json:"id"`
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	FrequencyMs    int32     `json:"frequency_ms"`
	InstanceNum    int16     `json:"instance_num"`
	SlotID         int32     `json:"slot_id"`
	SlotCount      int32     `json:"slot_count"`
	RollupGroup    int64     `json:"rollup_group"`
	SegmentID      int64     `json:"segment_id"`
	RecordCount    int64     `json:"record_count"`
	QueueTs        time.Time `json:"queue_ts"`
}

func (q *Queries) MrqPickHead(ctx context.Context) (MrqPickHeadRow, error) {
	row := q.db.QueryRow(ctx, mrqPickHead)
	var i MrqPickHeadRow
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Dateint,
		&i.FrequencyMs,
		&i.InstanceNum,
		&i.SlotID,
		&i.SlotCount,
		&i.RollupGroup,
		&i.SegmentID,
		&i.RecordCount,
		&i.QueueTs,
	)
	return i, err
}

const mrqQueueWork = `-- name: MrqQueueWork :exec
INSERT INTO metric_rollup_queue (
  organization_id,
  dateint,
  frequency_ms,
  instance_num,
  slot_id,
  slot_count,
  segment_id,
  record_count,
  rollup_group,
  priority,
  eligible_at
)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  $11
)
`

type MrqQueueWorkParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	FrequencyMs    int32     `json:"frequency_ms"`
	InstanceNum    int16     `json:"instance_num"`
	SlotID         int32     `json:"slot_id"`
	SlotCount      int32     `json:"slot_count"`
	SegmentID      int64     `json:"segment_id"`
	RecordCount    int64     `json:"record_count"`
	RollupGroup    int64     `json:"rollup_group"`
	Priority       int32     `json:"priority"`
	EligibleAt     time.Time `json:"eligible_at"`
}

func (q *Queries) MrqQueueWork(ctx context.Context, arg MrqQueueWorkParams) error {
	_, err := q.db.Exec(ctx, mrqQueueWork,
		arg.OrganizationID,
		arg.Dateint,
		arg.FrequencyMs,
		arg.InstanceNum,
		arg.SlotID,
		arg.SlotCount,
		arg.SegmentID,
		arg.RecordCount,
		arg.RollupGroup,
		arg.Priority,
		arg.EligibleAt,
	)
	return err
}

const mrqReclaimTimeouts = `-- name: MrqReclaimTimeouts :execrows
WITH stale AS (
  SELECT id
  FROM public.metric_rollup_queue
  WHERE claimed_by <> -1
    AND heartbeated_at < (now() - $1::interval)
  LIMIT $2
)
UPDATE public.metric_rollup_queue q
SET claimed_by = -1, claimed_at = NULL, heartbeated_at = NULL, tries = q.tries + 1
FROM stale s
WHERE q.id = s.id
`

type MrqReclaimTimeoutsParams struct {
	MaxAge  time.Duration `json:"max_age"`
	MaxRows int32         `json:"max_rows"`
}

func (q *Queries) MrqReclaimTimeouts(ctx context.Context, arg MrqReclaimTimeoutsParams) (int64, error) {
	result, err := q.db.Exec(ctx, mrqReclaimTimeouts, arg.MaxAge, arg.MaxRows)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const mrqRelease = `-- name: MrqRelease :exec
UPDATE public.metric_rollup_queue
SET claimed_by = -1, claimed_at = NULL, heartbeated_at = NULL, tries = tries + 1
WHERE claimed_by = $1 AND id = ANY($2::bigint[])
`

type MrqReleaseParams struct {
	WorkerID int64   `json:"worker_id"`
	Ids      []int64 `json:"ids"`
}

func (q *Queries) MrqRelease(ctx context.Context, arg MrqReleaseParams) error {
	_, err := q.db.Exec(ctx, mrqRelease, arg.WorkerID, arg.Ids)
	return err
}
