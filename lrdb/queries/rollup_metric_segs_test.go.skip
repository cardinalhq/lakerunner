//go:build integration

// Copyright (C) 2025 CardinalHQ, Inc
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, version 3.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

package queries

import (
	"context"
	"testing"
	"time"

	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/cardinalhq/lakerunner/lrdb"
	"github.com/cardinalhq/lakerunner/testhelpers"
)

func TestRollupMetricSegs_BasicRollup(t *testing.T) {
	ctx := context.Background()
	db := testhelpers.NewTestLRDBStore(t)

	orgID := uuid.New()
	now := time.Now()

	// Create source segments at 10s frequency that will be rolled up
	sourceSegmentIDs := []int64{10001, 10002}
	for _, segmentID := range sourceSegmentIDs {
		err := db.InsertMetricSegment(ctx, lrdb.InsertMetricSegmentParams{
			OrganizationID: orgID,
			Dateint:        20250830,
			IngestDateint:  20250830,
			FrequencyMs:    10000, // 10 seconds - source frequency
			SegmentID:      segmentID,
			InstanceNum:    1,
			SlotID:         0,
			StartTs:        now.UnixMilli(),
			EndTs:          now.Add(10 * time.Second).UnixMilli(),
			RecordCount:    600,
			FileSize:       30000,
			CreatedBy:      lrdb.CreatedByIngest,
			Published:      true,
			Fingerprints:   []int64{100 + segmentID, 200 + segmentID},
			SortVersion:    lrdb.CurrentMetricSortVersion,
			SlotCount:      1,
			Compacted:      false,
		})
		require.NoError(t, err)
	}

	// Create existing target segment at 1min frequency to replace
	existingTargetSegmentID := int64(20001)
	err := db.InsertMetricSegment(ctx, lrdb.InsertMetricSegmentParams{
		OrganizationID: orgID,
		Dateint:        20250830,
		IngestDateint:  20250830,
		FrequencyMs:    60000, // 1 minute - target frequency
		SegmentID:      existingTargetSegmentID,
		InstanceNum:    1,
		SlotID:         0,
		StartTs:        now.UnixMilli(),
		EndTs:          now.Add(time.Minute).UnixMilli(),
		RecordCount:    100,
		FileSize:       5000,
		CreatedBy:      lrdb.CreatedByIngest,
		Published:      true,
		Fingerprints:   []int64{777},
		SortVersion:    lrdb.CurrentMetricSortVersion,
		SlotCount:      1,
		Compacted:      false,
	})
	require.NoError(t, err)

	// Perform rollup operation using RollupMetricSegs
	sourceParams := lrdb.RollupSourceParams{
		OrganizationID: orgID,
		Dateint:        20250830,
		FrequencyMs:    10000, // Source frequency
		InstanceNum:    1,
	}
	targetParams := lrdb.RollupTargetParams{
		OrganizationID: orgID,
		Dateint:        20250830,
		FrequencyMs:    60000, // Target frequency
		InstanceNum:    1,
		SlotID:         0,
		SlotCount:      1,
		IngestDateint:  20250830,
		SortVersion:    lrdb.CurrentMetricSortVersion,
	}
	newRecords := []lrdb.RollupNewRecord{
		{
			SegmentID:    30001,
			StartTs:      now.UnixMilli(),
			EndTs:        now.Add(time.Minute).UnixMilli(),
			RecordCount:  120, // Rolled up from 600 + 600 = 1200 to 120
			FileSize:     12000,
			Fingerprints: []int64{9001, 9002},
		},
	}
	err = db.RollupMetricSegs(ctx, sourceParams, targetParams, sourceSegmentIDs, newRecords)
	require.NoError(t, err)

	// Verify source segments were marked as rolled up (but still exist)
	sourceSegs, err := db.GetMetricSegsByIds(ctx, lrdb.GetMetricSegsByIdsParams{
		OrganizationID: orgID,
		Dateint:        20250830,
		FrequencyMs:    10000,
		InstanceNum:    1,
		SegmentIds:     sourceSegmentIDs,
	})
	require.NoError(t, err)

	sourceSegMap := make(map[int64]lrdb.MetricSeg)
	for _, seg := range sourceSegs {
		sourceSegMap[seg.SegmentID] = seg
	}

	for _, segmentID := range sourceSegmentIDs {
		seg, exists := sourceSegMap[segmentID]
		require.True(t, exists, "Source segment should still exist")
		assert.True(t, seg.Rolledup, "Source segment should be marked as rolled up")
		assert.True(t, seg.Published, "Source segment should remain published") // Unlike compaction
		assert.False(t, seg.Compacted, "Source segment should not be compacted")
	}

	// Verify target segments - new implementation only inserts, doesn't delete old ones
	// Check both the existing target segment and the new one
	targetSegmentIDs := []int64{existingTargetSegmentID, 30001} // existing and new
	targetSegs, err := db.GetMetricSegsByIds(ctx, lrdb.GetMetricSegsByIdsParams{
		OrganizationID: orgID,
		Dateint:        20250830,
		FrequencyMs:    60000,
		InstanceNum:    1,
		SegmentIds:     targetSegmentIDs,
	})
	require.NoError(t, err)

	targetSegMap := make(map[int64]lrdb.MetricSeg)
	for _, seg := range targetSegs {
		targetSegMap[seg.SegmentID] = seg
	}

	// Old target segment should still exist (new implementation doesn't delete)
	oldSeg, oldExists := targetSegMap[existingTargetSegmentID]
	require.True(t, oldExists, "Old target segment should still exist")
	assert.Equal(t, []int64{777}, oldSeg.Fingerprints)

	// New target segment should exist
	newSeg, newExists := targetSegMap[30001]
	require.True(t, newExists, "New target segment should exist")
	assert.False(t, newSeg.Rolledup, "New target segment should not be rolled up")
	assert.True(t, newSeg.Published, "New target segment should be published")
	assert.False(t, newSeg.Compacted, "New target segment should not be compacted")
	assert.Equal(t, int64(120), newSeg.RecordCount)
	assert.Equal(t, int64(12000), newSeg.FileSize)
	assert.Equal(t, []int64{9001, 9002}, newSeg.Fingerprints)
	assert.Equal(t, lrdb.CreateByRollup, newSeg.CreatedBy)
}

func TestRollupMetricSegs_EmptySourceSegments(t *testing.T) {
	ctx := context.Background()
	db := testhelpers.NewTestLRDBStore(t)

	orgID := uuid.New()
	now := time.Now()

	// Create existing target segment to replace
	existingTargetID := int64(40001)
	err := db.InsertMetricSegment(ctx, lrdb.InsertMetricSegmentParams{
		OrganizationID: orgID,
		Dateint:        20250830,
		IngestDateint:  20250830,
		FrequencyMs:    60000,
		SegmentID:      existingTargetID,
		InstanceNum:    1,
		SlotID:         0,
		StartTs:        now.UnixMilli(),
		EndTs:          now.Add(time.Minute).UnixMilli(),
		RecordCount:    100,
		FileSize:       5000,
		CreatedBy:      lrdb.CreatedByIngest,
		Published:      true,
		Fingerprints:   []int64{888},
		SortVersion:    lrdb.CurrentMetricSortVersion,
		SlotCount:      1,
	})
	require.NoError(t, err)

	// Test rollup with no source segments to mark (just replace target)
	sourceParams := lrdb.RollupSourceParams{
		OrganizationID: orgID,
		Dateint:        20250830,
		FrequencyMs:    10000,
		InstanceNum:    1,
	}
	targetParams := lrdb.RollupTargetParams{
		OrganizationID: orgID,
		Dateint:        20250830,
		FrequencyMs:    60000,
		InstanceNum:    1,
		SlotID:         0,
		SlotCount:      1,
		IngestDateint:  20250830,
		SortVersion:    lrdb.CurrentMetricSortVersion,
	}
	newRecords := []lrdb.RollupNewRecord{
		{
			SegmentID:    50001,
			StartTs:      now.UnixMilli(),
			EndTs:        now.Add(time.Minute).UnixMilli(),
			RecordCount:  200,
			FileSize:     10000,
			Fingerprints: []int64{5001, 5002},
		},
	}
	emptySourceSegmentIDs := []int64{} // Empty source segments
	err = db.RollupMetricSegs(ctx, sourceParams, targetParams, emptySourceSegmentIDs, newRecords)
	require.NoError(t, err)

	// Verify target was added (old one should still exist, new one added)
	targetSegmentIDs := []int64{existingTargetSegmentID, 40001}
	segs, err := db.GetMetricSegsByIds(ctx, lrdb.GetMetricSegsByIdsParams{
		OrganizationID: orgID,
		Dateint:        20250830,
		FrequencyMs:    60000,
		InstanceNum:    1,
		SegmentIds:     targetSegmentIDs,
	})
	require.NoError(t, err)
	require.Len(t, segs, 2) // Both old and new should exist

	segMap := make(map[int64]lrdb.MetricSeg)
	for _, seg := range segs {
		segMap[seg.SegmentID] = seg
	}

	// Original segment should still exist
	origSeg, origExists := segMap[existingTargetID]
	require.True(t, origExists, "Original target segment should still exist")
	assert.Equal(t, []int64{888}, origSeg.Fingerprints)

	// New segment should exist
	newSeg, newExists := segMap[50001]
	require.True(t, newExists, "New target segment should exist")
	assert.Equal(t, int64(200), newSeg.RecordCount)
	assert.Equal(t, []int64{5001, 5002}, newSeg.Fingerprints)
}

func TestRollupMetricSegs_EmptyTargetReplacement(t *testing.T) {
	ctx := context.Background()
	db := testhelpers.NewTestLRDBStore(t)

	orgID := uuid.New()
	now := time.Now()

	// Create source segments to mark as rolled up
	sourceSegmentIDs := []int64{60001, 60002}
	for _, segmentID := range sourceSegmentIDs {
		err := db.InsertMetricSegment(ctx, lrdb.InsertMetricSegmentParams{
			OrganizationID: orgID,
			Dateint:        20250830,
			IngestDateint:  20250830,
			FrequencyMs:    10000,
			SegmentID:      segmentID,
			InstanceNum:    1,
			SlotID:         0,
			StartTs:        now.UnixMilli(),
			EndTs:          now.Add(10 * time.Second).UnixMilli(),
			RecordCount:    300,
			FileSize:       15000,
			CreatedBy:      lrdb.CreatedByIngest,
			Published:      true,
			Fingerprints:   []int64{600 + segmentID},
			SortVersion:    lrdb.CurrentMetricSortVersion,
			SlotCount:      1,
		})
		require.NoError(t, err)
	}

	// Test rollup with just marking source segments (no target replacement)
	sourceParams := lrdb.RollupSourceParams{
		OrganizationID: orgID,
		Dateint:        20250830,
		FrequencyMs:    10000,
		InstanceNum:    1,
	}
	targetParams := lrdb.RollupTargetParams{
		OrganizationID: orgID,
		Dateint:        20250830,
		FrequencyMs:    60000,
		InstanceNum:    1,
		SlotID:         0,
		SlotCount:      1,
		IngestDateint:  20250830,
		SortVersion:    lrdb.CurrentMetricSortVersion,
	}
	emptyNewRecords := []lrdb.RollupNewRecord{} // Empty
	err := db.RollupMetricSegs(ctx, sourceParams, targetParams, sourceSegmentIDs, emptyNewRecords)
	require.NoError(t, err)

	// Verify source segments were marked as rolled up
	segs, err := db.GetMetricSegsForRollup(ctx, lrdb.GetMetricSegsForRollupParams{
		OrganizationID: orgID,
		Dateint:        20250830,
		FrequencyMs:    10000,
		InstanceNum:    1,
		SlotID:         0,
	})
	require.NoError(t, err)

	segMap := make(map[int64]lrdb.MetricSeg)
	for _, seg := range segs {
		segMap[seg.SegmentID] = seg
	}

	for _, segmentID := range sourceSegmentIDs {
		seg, exists := segMap[segmentID]
		require.True(t, exists, "Source segment should exist")
		assert.True(t, seg.Rolledup, "Source segment should be marked as rolled up")
		assert.True(t, seg.Published, "Source segment should remain published")
	}
}

func TestRollupMetricSegs_MultipleTargetSegments(t *testing.T) {
	ctx := context.Background()
	db := testhelpers.NewTestLRDBStore(t)

	orgID := uuid.New()
	now := time.Now()

	// Create source segments
	sourceSegmentIDs := []int64{70001, 70002, 70003}
	for _, segmentID := range sourceSegmentIDs {
		err := db.InsertMetricSegment(ctx, lrdb.InsertMetricSegmentParams{
			OrganizationID: orgID,
			Dateint:        20250830,
			IngestDateint:  20250830,
			FrequencyMs:    10000,
			SegmentID:      segmentID,
			InstanceNum:    1,
			SlotID:         0,
			StartTs:        now.UnixMilli(),
			EndTs:          now.Add(10 * time.Second).UnixMilli(),
			RecordCount:    400,
			FileSize:       20000,
			CreatedBy:      lrdb.CreatedByIngest,
			Published:      true,
			Fingerprints:   []int64{700 + segmentID},
			SortVersion:    lrdb.CurrentMetricSortVersion,
			SlotCount:      1,
		})
		require.NoError(t, err)
	}

	// Create multiple existing target segments to replace
	existingTargetIDs := []int64{80001, 80002}
	for _, segmentID := range existingTargetIDs {
		err := db.InsertMetricSegment(ctx, lrdb.InsertMetricSegmentParams{
			OrganizationID: orgID,
			Dateint:        20250830,
			IngestDateint:  20250830,
			FrequencyMs:    60000,
			SegmentID:      segmentID,
			InstanceNum:    1,
			SlotID:         0,
			StartTs:        now.UnixMilli(),
			EndTs:          now.Add(time.Minute).UnixMilli(),
			RecordCount:    150,
			FileSize:       7500,
			CreatedBy:      lrdb.CreatedByIngest,
			Published:      true,
			Fingerprints:   []int64{800 + segmentID},
			SortVersion:    lrdb.CurrentMetricSortVersion,
			SlotCount:      1,
		})
		require.NoError(t, err)
	}

	// Test rollup with multiple target segments
	sourceParams := lrdb.RollupSourceParams{
		OrganizationID: orgID,
		Dateint:        20250830,
		FrequencyMs:    10000,
		InstanceNum:    1,
	}
	targetParams := lrdb.RollupTargetParams{
		OrganizationID: orgID,
		Dateint:        20250830,
		FrequencyMs:    60000,
		InstanceNum:    1,
		SlotID:         0,
		SlotCount:      1,
		IngestDateint:  20250830,
		SortVersion:    lrdb.CurrentMetricSortVersion,
	}
	newRecords := []lrdb.RollupNewRecord{
		{
			SegmentID:    90001,
			StartTs:      now.UnixMilli(),
			EndTs:        now.Add(30 * time.Second).UnixMilli(),
			RecordCount:  200,
			FileSize:     20000,
			Fingerprints: []int64{9001, 9101},
		},
		{
			SegmentID:    90002,
			StartTs:      now.Add(30 * time.Second).UnixMilli(),
			EndTs:        now.Add(time.Minute).UnixMilli(),
			RecordCount:  180,
			FileSize:     18000,
			Fingerprints: []int64{9002, 9102},
		},
	}
	err := db.RollupMetricSegs(ctx, sourceParams, targetParams, sourceSegmentIDs, newRecords)
	require.NoError(t, err)

	// Verify source segments marked as rolled up
	sourceSegs, err := db.GetMetricSegsForRollup(ctx, lrdb.GetMetricSegsForRollupParams{
		OrganizationID: orgID,
		Dateint:        20250830,
		FrequencyMs:    10000,
		InstanceNum:    1,
		SlotID:         0,
	})
	require.NoError(t, err)

	sourceSegMap := make(map[int64]lrdb.MetricSeg)
	for _, seg := range sourceSegs {
		sourceSegMap[seg.SegmentID] = seg
	}

	for _, segmentID := range sourceSegmentIDs {
		seg, exists := sourceSegMap[segmentID]
		require.True(t, exists)
		assert.True(t, seg.Rolledup, "Source segment should be rolled up")
	}

	// Verify target segments - old ones should still exist, new ones added
	targetSegs, err := db.GetMetricSegsForRollup(ctx, lrdb.GetMetricSegsForRollupParams{
		OrganizationID: orgID,
		Dateint:        20250830,
		FrequencyMs:    60000,
		InstanceNum:    1,
		SlotID:         0,
	})
	require.NoError(t, err)
	require.Len(t, targetSegs, 4) // 2 old + 2 new

	targetSegMap := make(map[int64]lrdb.MetricSeg)
	for _, seg := range targetSegs {
		targetSegMap[seg.SegmentID] = seg
	}

	// Old target segments should still exist
	for _, oldID := range existingTargetIDs {
		oldSeg, exists := targetSegMap[oldID]
		require.True(t, exists, "Old target segment should still exist")
		assert.Equal(t, []int64{800 + oldID}, oldSeg.Fingerprints)
	}

	// New target segments should exist
	newSeg1, exists1 := targetSegMap[90001]
	require.True(t, exists1)
	assert.Equal(t, int64(200), newSeg1.RecordCount)
	assert.Equal(t, []int64{9001, 9101}, newSeg1.Fingerprints)

	newSeg2, exists2 := targetSegMap[90002]
	require.True(t, exists2)
	assert.Equal(t, int64(180), newSeg2.RecordCount)
	assert.Equal(t, []int64{9002, 9102}, newSeg2.Fingerprints)
}

func TestRollupMetricSegs_AtomicTransactionFailure(t *testing.T) {
	ctx := context.Background()
	db := testhelpers.NewTestLRDBStore(t)

	orgID := uuid.New()
	now := time.Now()

	// Create source segment
	sourceSegmentID := int64(99001)
	err := db.InsertMetricSegment(ctx, lrdb.InsertMetricSegmentParams{
		OrganizationID: orgID,
		Dateint:        20250830,
		IngestDateint:  20250830,
		FrequencyMs:    10000,
		SegmentID:      sourceSegmentID,
		InstanceNum:    1,
		SlotID:         0,
		StartTs:        now.UnixMilli(),
		EndTs:          now.Add(10 * time.Second).UnixMilli(),
		RecordCount:    500,
		FileSize:       25000,
		CreatedBy:      lrdb.CreatedByIngest,
		Published:      true,
		Fingerprints:   []int64{990},
		SortVersion:    lrdb.CurrentMetricSortVersion,
		SlotCount:      1,
	})
	require.NoError(t, err)

	// Test transaction rollback by trying to insert a segment with duplicate primary key
	// First, create a segment that will conflict
	conflictingSegmentID := int64(99999)
	err = db.InsertMetricSegment(ctx, lrdb.InsertMetricSegmentParams{
		OrganizationID: orgID,
		Dateint:        20250830,
		IngestDateint:  20250830,
		FrequencyMs:    60000,
		SegmentID:      conflictingSegmentID,
		InstanceNum:    1,
		SlotID:         0,
		StartTs:        now.UnixMilli(),
		EndTs:          now.Add(time.Minute).UnixMilli(),
		RecordCount:    100,
		FileSize:       5000,
		CreatedBy:      lrdb.CreatedByIngest,
		Published:      true,
		Fingerprints:   []int64{999},
		SortVersion:    lrdb.CurrentMetricSortVersion,
		SlotCount:      1,
	})
	require.NoError(t, err)

	// Try to rollup with a new record that has the same primary key (should fail)
	sourceParams := lrdb.RollupSourceParams{
		OrganizationID: orgID,
		Dateint:        20250830,
		FrequencyMs:    10000,
		InstanceNum:    1,
	}
	targetParams := lrdb.RollupTargetParams{
		OrganizationID: orgID,
		Dateint:        20250830,
		FrequencyMs:    60000,
		InstanceNum:    1,
		SlotID:         0,
		SlotCount:      1,
		IngestDateint:  20250830,
		SortVersion:    lrdb.CurrentMetricSortVersion,
	}
	newRecords := []lrdb.RollupNewRecord{
		{
			SegmentID:    conflictingSegmentID, // This will cause a primary key violation
			StartTs:      now.UnixMilli(),
			EndTs:        now.Add(time.Minute).UnixMilli(),
			RecordCount:  200,
			FileSize:     10000,
			Fingerprints: []int64{9999},
		},
	}
	err = db.RollupMetricSegs(ctx, sourceParams, targetParams, []int64{sourceSegmentID}, newRecords)
	// Should fail due to primary key violation
	require.Error(t, err)

	// Verify that source segment was NOT marked as rolled up due to transaction rollback
	sourceSegs, err := db.GetMetricSegsForRollup(ctx, lrdb.GetMetricSegsForRollupParams{
		OrganizationID: orgID,
		Dateint:        20250830,
		FrequencyMs:    10000,
		InstanceNum:    1,
		SlotID:         0,
	})
	require.NoError(t, err)
	require.Len(t, sourceSegs, 1)

	sourceSeg := sourceSegs[0]
	assert.Equal(t, sourceSegmentID, sourceSeg.SegmentID)
	assert.False(t, sourceSeg.Rolledup, "Source segment should NOT be marked as rolled up due to transaction failure")
	assert.True(t, sourceSeg.Published, "Source segment should remain published")

	// Verify original conflicting segment still exists unchanged
	targetSegs, err := db.GetMetricSegsForRollup(ctx, lrdb.GetMetricSegsForRollupParams{
		OrganizationID: orgID,
		Dateint:        20250830,
		FrequencyMs:    60000,
		InstanceNum:    1,
		SlotID:         0,
	})
	require.NoError(t, err)
	require.Len(t, targetSegs, 1)

	targetSeg := targetSegs[0]
	assert.Equal(t, conflictingSegmentID, targetSeg.SegmentID)
	assert.Equal(t, int64(100), targetSeg.RecordCount)    // Original record count
	assert.Equal(t, []int64{999}, targetSeg.Fingerprints) // Original fingerprints
}

func TestRollupMetricSegs_DifferentOrganizations(t *testing.T) {
	ctx := context.Background()
	db := testhelpers.NewTestLRDBStore(t)

	orgID1 := uuid.New()
	orgID2 := uuid.New()
	now := time.Now()

	// Create source segment for org1
	sourceSegmentID := int64(100001)
	err := db.InsertMetricSegment(ctx, lrdb.InsertMetricSegmentParams{
		OrganizationID: orgID1,
		Dateint:        20250830,
		IngestDateint:  20250830,
		FrequencyMs:    10000,
		SegmentID:      sourceSegmentID,
		InstanceNum:    1,
		SlotID:         0,
		StartTs:        now.UnixMilli(),
		EndTs:          now.Add(10 * time.Second).UnixMilli(),
		RecordCount:    300,
		FileSize:       15000,
		CreatedBy:      lrdb.CreatedByIngest,
		Published:      true,
		Fingerprints:   []int64{1001},
		SortVersion:    lrdb.CurrentMetricSortVersion,
		SlotCount:      1,
	})
	require.NoError(t, err)

	// Create target segment for org2 (different org)
	targetSegmentID := int64(200001)
	err = db.InsertMetricSegment(ctx, lrdb.InsertMetricSegmentParams{
		OrganizationID: orgID2,
		Dateint:        20250830,
		IngestDateint:  20250830,
		FrequencyMs:    60000,
		SegmentID:      targetSegmentID,
		InstanceNum:    1,
		SlotID:         0,
		StartTs:        now.UnixMilli(),
		EndTs:          now.Add(time.Minute).UnixMilli(),
		RecordCount:    100,
		FileSize:       5000,
		CreatedBy:      lrdb.CreatedByIngest,
		Published:      true,
		Fingerprints:   []int64{2001},
		SortVersion:    lrdb.CurrentMetricSortVersion,
		SlotCount:      1,
	})
	require.NoError(t, err)

	// Rollup should work on different organizations independently
	sourceParams := lrdb.RollupSourceParams{
		OrganizationID: orgID1, // Source from org1
		Dateint:        20250830,
		FrequencyMs:    10000,
		InstanceNum:    1,
	}
	targetParams := lrdb.RollupTargetParams{
		OrganizationID: orgID2, // Target in org2
		Dateint:        20250830,
		FrequencyMs:    60000,
		InstanceNum:    1,
		SlotID:         0,
		SlotCount:      1,
		IngestDateint:  20250830,
		SortVersion:    lrdb.CurrentMetricSortVersion,
	}
	newRecords := []lrdb.RollupNewRecord{
		{
			SegmentID:    300001,
			StartTs:      now.UnixMilli(),
			EndTs:        now.Add(time.Minute).UnixMilli(),
			RecordCount:  150,
			FileSize:     7500,
			Fingerprints: []int64{3001},
		},
	}
	err = db.RollupMetricSegs(ctx, sourceParams, targetParams, []int64{sourceSegmentID}, newRecords)
	require.NoError(t, err)

	// Verify org1 source segment was marked as rolled up
	sourceSegs, err := db.GetMetricSegsForRollup(ctx, lrdb.GetMetricSegsForRollupParams{
		OrganizationID: orgID1,
		Dateint:        20250830,
		FrequencyMs:    10000,
		InstanceNum:    1,
		SlotID:         0,
	})
	require.NoError(t, err)
	require.Len(t, sourceSegs, 1)
	assert.True(t, sourceSegs[0].Rolledup, "Org1 source segment should be rolled up")

	// Verify org2 target segment - old one should still exist, new one added
	targetSegs, err := db.GetMetricSegsForRollup(ctx, lrdb.GetMetricSegsForRollupParams{
		OrganizationID: orgID2,
		Dateint:        20250830,
		FrequencyMs:    60000,
		InstanceNum:    1,
		SlotID:         0,
	})
	require.NoError(t, err)
	require.Len(t, targetSegs, 2) // Both old and new should exist

	targetSegMap := make(map[int64]lrdb.MetricSeg)
	for _, seg := range targetSegs {
		targetSegMap[seg.SegmentID] = seg
	}

	// Original segment should still exist
	origSeg, origExists := targetSegMap[targetSegmentID]
	require.True(t, origExists, "Original target segment should still exist")
	assert.Equal(t, []int64{2001}, origSeg.Fingerprints)

	// New segment should exist
	newSeg, newExists := targetSegMap[300001]
	require.True(t, newExists, "New target segment should exist")
	assert.Equal(t, []int64{3001}, newSeg.Fingerprints)
}

func TestRollupMetricSegs_DifferentSlots(t *testing.T) {
	ctx := context.Background()
	db := testhelpers.NewTestLRDBStore(t)

	orgID := uuid.New()
	now := time.Now()

	// Create source segments in slot 0
	sourceSegmentIDs := []int64{110001, 110002}
	for _, segmentID := range sourceSegmentIDs {
		err := db.InsertMetricSegment(ctx, lrdb.InsertMetricSegmentParams{
			OrganizationID: orgID,
			Dateint:        20250830,
			IngestDateint:  20250830,
			FrequencyMs:    10000,
			SegmentID:      segmentID,
			InstanceNum:    1,
			SlotID:         0, // Slot 0
			StartTs:        now.UnixMilli(),
			EndTs:          now.Add(10 * time.Second).UnixMilli(),
			RecordCount:    200,
			FileSize:       10000,
			CreatedBy:      lrdb.CreatedByIngest,
			Published:      true,
			Fingerprints:   []int64{1100 + segmentID},
			SortVersion:    lrdb.CurrentMetricSortVersion,
			SlotCount:      2, // 2 slots total
		})
		require.NoError(t, err)
	}

	// Create target segments in slot 1
	targetSegmentID := int64(120001)
	err := db.InsertMetricSegment(ctx, lrdb.InsertMetricSegmentParams{
		OrganizationID: orgID,
		Dateint:        20250830,
		IngestDateint:  20250830,
		FrequencyMs:    60000,
		SegmentID:      targetSegmentID,
		InstanceNum:    1,
		SlotID:         1, // Slot 1
		StartTs:        now.UnixMilli(),
		EndTs:          now.Add(time.Minute).UnixMilli(),
		RecordCount:    50,
		FileSize:       2500,
		CreatedBy:      lrdb.CreatedByIngest,
		Published:      true,
		Fingerprints:   []int64{1201},
		SortVersion:    lrdb.CurrentMetricSortVersion,
		SlotCount:      2, // 2 slots total
	})
	require.NoError(t, err)

	// Rollup from slot 0 source to slot 1 target
	sourceParams := lrdb.RollupSourceParams{
		OrganizationID: orgID,
		Dateint:        20250830,
		FrequencyMs:    10000,
		InstanceNum:    1,
	}
	targetParams := lrdb.RollupTargetParams{
		OrganizationID: orgID,
		Dateint:        20250830,
		FrequencyMs:    60000,
		InstanceNum:    1,
		SlotID:         1, // Target slot 1
		SlotCount:      2,
		IngestDateint:  20250830,
		SortVersion:    lrdb.CurrentMetricSortVersion,
	}
	newRecords := []lrdb.RollupNewRecord{
		{
			SegmentID:    130001,
			StartTs:      now.UnixMilli(),
			EndTs:        now.Add(time.Minute).UnixMilli(),
			RecordCount:  80,
			FileSize:     4000,
			Fingerprints: []int64{1301},
		},
	}
	err = db.RollupMetricSegs(ctx, sourceParams, targetParams, sourceSegmentIDs, newRecords)
	require.NoError(t, err)

	// Verify source segments in slot 0 were marked as rolled up
	sourceSegs, err := db.GetMetricSegsForRollup(ctx, lrdb.GetMetricSegsForRollupParams{
		OrganizationID: orgID,
		Dateint:        20250830,
		FrequencyMs:    10000,
		InstanceNum:    1,
		SlotID:         0, // Check slot 0
	})
	require.NoError(t, err)

	sourceSegMap := make(map[int64]lrdb.MetricSeg)
	for _, seg := range sourceSegs {
		sourceSegMap[seg.SegmentID] = seg
	}

	for _, segmentID := range sourceSegmentIDs {
		seg, exists := sourceSegMap[segmentID]
		require.True(t, exists)
		assert.True(t, seg.Rolledup, "Source segment in slot 0 should be rolled up")
		assert.Equal(t, int32(0), seg.SlotID)
		assert.Equal(t, int32(2), seg.SlotCount)
	}

	// Verify target segment in slot 1 - old one should still exist, new one added
	targetSegs, err := db.GetMetricSegsForRollup(ctx, lrdb.GetMetricSegsForRollupParams{
		OrganizationID: orgID,
		Dateint:        20250830,
		FrequencyMs:    60000,
		InstanceNum:    1,
		SlotID:         1, // Check slot 1
	})
	require.NoError(t, err)
	require.Len(t, targetSegs, 2) // Both old and new should exist

	targetSegMap := make(map[int64]lrdb.MetricSeg)
	for _, seg := range targetSegs {
		targetSegMap[seg.SegmentID] = seg
	}

	// Original segment should still exist
	origSeg, origExists := targetSegMap[targetSegmentID]
	require.True(t, origExists, "Original target segment should still exist")
	assert.Equal(t, int32(1), origSeg.SlotID)
	assert.Equal(t, int32(2), origSeg.SlotCount)
	assert.Equal(t, []int64{1201}, origSeg.Fingerprints)

	// New segment should exist
	newSeg, newExists := targetSegMap[130001]
	require.True(t, newExists, "New target segment should exist")
	assert.Equal(t, int32(1), newSeg.SlotID)
	assert.Equal(t, int32(2), newSeg.SlotCount)
	assert.Equal(t, []int64{1301}, newSeg.Fingerprints)
}
