-- 1758103789_recent_metric_stats_debug.up.sql

-- Code generated by database migration. DO NOT EDIT.

CREATE OR REPLACE FUNCTION lr_recent_metric_stats(
    p_org_id uuid DEFAULT '65928f26-224b-4acb-8e57-9ee628164694',
    p_lookback_hours int DEFAULT 4
)
RETURNS TABLE (
    created_by text,
    organization_id uuid,
    dateint int,
    hour int,
    c_10s bigint,
    afs_10s bigint,
    c_60s bigint,
    afs_60s bigint,
    c_5m bigint,
    afs_5m bigint,
    c_20m bigint,
    afs_20m bigint,
    c_60m bigint,
    afs_60m bigint
)
LANGUAGE sql
AS $$
WITH params AS (
  SELECT
    p_org_id AS org_id,
    GREATEST(COALESCE(p_lookback_hours, 4), 1) AS lookback_hours,
    NOW() AS now_ts
),
bounds AS (
  SELECT
    org_id,
    date_trunc('hour', now_ts) AS current_hour_start,
    date_trunc('hour', now_ts) - make_interval(hours => lookback_hours - 1) AS lookback_start,
    date_trunc('hour', now_ts) + interval '1 hour' AS lookback_end,
    to_char((date_trunc('hour', now_ts) - make_interval(hours => lookback_hours - 1))::date, 'YYYYMMDD')::int AS min_dateint,
    to_char(now_ts::date, 'YYYYMMDD')::int AS max_dateint
  FROM params
),
recent AS (
  SELECT
    m.organization_id,
    m.dateint,
    m.frequency_ms,
    m.file_size,
    m.created_by,
    date_trunc('hour', to_timestamp(lower(m.ts_range) / 1000.0)) AS segment_hour,
    b.lookback_start,
    b.lookback_end
  FROM metric_seg m
  JOIN bounds b ON TRUE
  WHERE m.published = TRUE
    AND m.organization_id = b.org_id
    AND m.dateint BETWEEN b.min_dateint AND b.max_dateint
),
filtered AS (
  SELECT
    organization_id,
    dateint,
    frequency_ms,
    file_size,
    created_by,
    segment_hour
  FROM recent
  WHERE segment_hour >= lookback_start
    AND segment_hour < lookback_end
)
SELECT
  CASE created_by
    WHEN 1 THEN 'ingest'
    WHEN 2 THEN 'compact'
    WHEN 3 THEN 'rollup'
    ELSE created_by::text
  END AS created_by,
  organization_id,
  dateint,
  EXTRACT(HOUR FROM segment_hour)::int AS hour,

  COUNT(*) FILTER (WHERE frequency_ms = 10000)                       AS c_10s,
  ROUND(AVG(file_size) FILTER (WHERE frequency_ms = 10000))::bigint  AS afs_10s,

  COUNT(*) FILTER (WHERE frequency_ms = 60000)                       AS c_60s,
  ROUND(AVG(file_size) FILTER (WHERE frequency_ms = 60000))::bigint  AS afs_60s,

  COUNT(*) FILTER (WHERE frequency_ms = 300000)                      AS c_5m,
  ROUND(AVG(file_size) FILTER (WHERE frequency_ms = 300000))::bigint AS afs_5m,

  COUNT(*) FILTER (WHERE frequency_ms = 1200000)                     AS c_20m,
  ROUND(AVG(file_size) FILTER (WHERE frequency_ms = 1200000))::bigint AS afs_20m,

  COUNT(*) FILTER (WHERE frequency_ms = 3600000)                     AS c_60m,
  ROUND(AVG(file_size) FILTER (WHERE frequency_ms = 3600000))::bigint AS afs_60m

FROM filtered
GROUP BY
  organization_id,
  created_by,
  dateint,
  EXTRACT(HOUR FROM segment_hour)::int
ORDER BY
  organization_id,
  dateint,
  hour,
  created_by;
$$;

CREATE OR REPLACE FUNCTION lr_recent_log_stats(
    p_org_id uuid DEFAULT '65928f26-224b-4acb-8e57-9ee628164694',
    p_lookback_hours int DEFAULT 4
)
RETURNS TABLE (
    created_by text,
    organization_id uuid,
    dateint int,
    hour int,
    c_segments bigint,
    afs_segments bigint
)
LANGUAGE sql
AS $$
WITH params AS (
  SELECT
    p_org_id AS org_id,
    GREATEST(COALESCE(p_lookback_hours, 4), 1) AS lookback_hours,
    NOW() AS now_ts
),
bounds AS (
  SELECT
    org_id,
    date_trunc('hour', now_ts) AS current_hour_start,
    date_trunc('hour', now_ts) - make_interval(hours => lookback_hours - 1) AS lookback_start,
    date_trunc('hour', now_ts) + interval '1 hour' AS lookback_end,
    to_char((date_trunc('hour', now_ts) - make_interval(hours => lookback_hours - 1))::date, 'YYYYMMDD')::int AS min_dateint,
    to_char(now_ts::date, 'YYYYMMDD')::int AS max_dateint
  FROM params
),
recent AS (
  SELECT
    l.organization_id,
    l.dateint,
    l.file_size,
    l.created_by,
    date_trunc('hour', to_timestamp(lower(l.ts_range) / 1000.0)) AS segment_hour,
    b.lookback_start,
    b.lookback_end
  FROM log_seg l
  JOIN bounds b ON TRUE
  WHERE l.published = TRUE
    AND l.organization_id = b.org_id
    AND l.dateint BETWEEN b.min_dateint AND b.max_dateint
),
filtered AS (
  SELECT
    organization_id,
    dateint,
    file_size,
    created_by,
    segment_hour
  FROM recent
  WHERE segment_hour >= lookback_start
    AND segment_hour < lookback_end
)
SELECT
  CASE created_by
    WHEN 1 THEN 'ingest'
    WHEN 2 THEN 'compact'
    WHEN 3 THEN 'rollup'
    ELSE created_by::text
  END AS created_by,
  organization_id,
  dateint,
  EXTRACT(HOUR FROM segment_hour)::int AS hour,
  COUNT(*) AS c_segments,
  ROUND(AVG(file_size))::bigint AS afs_segments
FROM filtered
GROUP BY
  organization_id,
  created_by,
  dateint,
  EXTRACT(HOUR FROM segment_hour)::int
ORDER BY
  organization_id,
  dateint,
  hour,
  created_by;
$$;

CREATE OR REPLACE FUNCTION lr_recent_trace_stats(
    p_org_id uuid DEFAULT '65928f26-224b-4acb-8e57-9ee628164694',
    p_lookback_hours int DEFAULT 4
)
RETURNS TABLE (
    created_by text,
    organization_id uuid,
    dateint int,
    hour int,
    c_segments bigint,
    afs_segments bigint
)
LANGUAGE sql
AS $$
WITH params AS (
  SELECT
    p_org_id AS org_id,
    GREATEST(COALESCE(p_lookback_hours, 4), 1) AS lookback_hours,
    NOW() AS now_ts
),
bounds AS (
  SELECT
    org_id,
    date_trunc('hour', now_ts) AS current_hour_start,
    date_trunc('hour', now_ts) - make_interval(hours => lookback_hours - 1) AS lookback_start,
    date_trunc('hour', now_ts) + interval '1 hour' AS lookback_end,
    to_char((date_trunc('hour', now_ts) - make_interval(hours => lookback_hours - 1))::date, 'YYYYMMDD')::int AS min_dateint,
    to_char(now_ts::date, 'YYYYMMDD')::int AS max_dateint
  FROM params
),
recent AS (
  SELECT
    t.organization_id,
    t.dateint,
    t.file_size,
    t.created_by,
    date_trunc('hour', to_timestamp(lower(t.ts_range) / 1000.0)) AS segment_hour,
    b.lookback_start,
    b.lookback_end
  FROM trace_seg t
  JOIN bounds b ON TRUE
  WHERE t.published = TRUE
    AND t.organization_id = b.org_id
    AND t.dateint BETWEEN b.min_dateint AND b.max_dateint
),
filtered AS (
  SELECT
    organization_id,
    dateint,
    file_size,
    created_by,
    segment_hour
  FROM recent
  WHERE segment_hour >= lookback_start
    AND segment_hour < lookback_end
)
SELECT
  CASE created_by
    WHEN 1 THEN 'ingest'
    WHEN 2 THEN 'compact'
    WHEN 3 THEN 'rollup'
    ELSE created_by::text
  END AS created_by,
  organization_id,
  dateint,
  EXTRACT(HOUR FROM segment_hour)::int AS hour,
  COUNT(*) AS c_segments,
  ROUND(AVG(file_size))::bigint AS afs_segments
FROM filtered
GROUP BY
  organization_id,
  created_by,
  dateint,
  EXTRACT(HOUR FROM segment_hour)::int
ORDER BY
  organization_id,
  dateint,
  hour,
  created_by;
$$;
