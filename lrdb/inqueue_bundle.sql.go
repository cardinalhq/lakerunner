// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: inqueue_bundle.sql

package lrdb

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const inqueueClaimBundle = `-- name: InqueueClaimBundle :exec
UPDATE public.inqueue
SET claimed_by = $1::bigint,
    claimed_at = now(),
    heartbeated_at = now()
WHERE id = ANY($2::uuid[])
  AND claimed_at IS NULL
`

type InqueueClaimBundleParams struct {
	Column1 int64       `json:"column_1"`
	Column2 []uuid.UUID `json:"column_2"`
}

// Claim a bundle of items
func (q *Queries) InqueueClaimBundle(ctx context.Context, arg InqueueClaimBundleParams) error {
	_, err := q.db.Exec(ctx, inqueueClaimBundle, arg.Column1, arg.Column2)
	return err
}

const inqueueDeferItems = `-- name: InqueueDeferItems :exec
UPDATE public.inqueue
SET eligible_at = now() + $1::interval
WHERE claimed_at IS NULL
  AND id = ANY($2::uuid[])
`

type InqueueDeferItemsParams struct {
	Column1 time.Duration `json:"column_1"`
	Column2 []uuid.UUID   `json:"column_2"`
}

// Defer items by pushing their eligible_at forward
func (q *Queries) InqueueDeferItems(ctx context.Context, arg InqueueDeferItemsParams) error {
	_, err := q.db.Exec(ctx, inqueueDeferItems, arg.Column1, arg.Column2)
	return err
}

const inqueueFetchCandidates = `-- name: InqueueFetchCandidates :many
SELECT id, organization_id, instance_num, signal, file_size, queue_ts, priority, 
       bucket, object_id, collector_name, tries
FROM public.inqueue  
WHERE claimed_at IS NULL
  AND signal = $1::text
  AND organization_id = $2::uuid
  AND instance_num = $3::smallint
  AND eligible_at <= now()
ORDER BY priority ASC, queue_ts ASC, id ASC
LIMIT $4::integer
FOR UPDATE
`

type InqueueFetchCandidatesParams struct {
	Column1 string    `json:"column_1"`
	Column2 uuid.UUID `json:"column_2"`
	Column3 int16     `json:"column_3"`
	Column4 int32     `json:"column_4"`
}

type InqueueFetchCandidatesRow struct {
	ID             uuid.UUID `json:"id"`
	OrganizationID uuid.UUID `json:"organization_id"`
	InstanceNum    int16     `json:"instance_num"`
	Signal         string    `json:"signal"`
	FileSize       int64     `json:"file_size"`
	QueueTs        time.Time `json:"queue_ts"`
	Priority       int32     `json:"priority"`
	Bucket         string    `json:"bucket"`
	ObjectID       string    `json:"object_id"`
	CollectorName  string    `json:"collector_name"`
	Tries          int32     `json:"tries"`
}

// Fetch all eligible candidates matching the grouping key
func (q *Queries) InqueueFetchCandidates(ctx context.Context, arg InqueueFetchCandidatesParams) ([]InqueueFetchCandidatesRow, error) {
	rows, err := q.db.Query(ctx, inqueueFetchCandidates,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InqueueFetchCandidatesRow
	for rows.Next() {
		var i InqueueFetchCandidatesRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.InstanceNum,
			&i.Signal,
			&i.FileSize,
			&i.QueueTs,
			&i.Priority,
			&i.Bucket,
			&i.ObjectID,
			&i.CollectorName,
			&i.Tries,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const inqueueGetBundleItems = `-- name: InqueueGetBundleItems :many
SELECT id, queue_ts, priority, organization_id, collector_name, instance_num,
       bucket, object_id, signal, tries, claimed_by, claimed_at, heartbeated_at,
       file_size, eligible_at
FROM public.inqueue
WHERE id = ANY($1::uuid[])
ORDER BY priority ASC, queue_ts ASC, id ASC
`

type InqueueGetBundleItemsRow struct {
	ID             uuid.UUID  `json:"id"`
	QueueTs        time.Time  `json:"queue_ts"`
	Priority       int32      `json:"priority"`
	OrganizationID uuid.UUID  `json:"organization_id"`
	CollectorName  string     `json:"collector_name"`
	InstanceNum    int16      `json:"instance_num"`
	Bucket         string     `json:"bucket"`
	ObjectID       string     `json:"object_id"`
	Signal         string     `json:"signal"`
	Tries          int32      `json:"tries"`
	ClaimedBy      int64      `json:"claimed_by"`
	ClaimedAt      *time.Time `json:"claimed_at"`
	HeartbeatedAt  *time.Time `json:"heartbeated_at"`
	FileSize       int64      `json:"file_size"`
	EligibleAt     time.Time  `json:"eligible_at"`
}

// Get full details for claimed bundle items
func (q *Queries) InqueueGetBundleItems(ctx context.Context, dollar_1 []uuid.UUID) ([]InqueueGetBundleItemsRow, error) {
	rows, err := q.db.Query(ctx, inqueueGetBundleItems, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InqueueGetBundleItemsRow
	for rows.Next() {
		var i InqueueGetBundleItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.QueueTs,
			&i.Priority,
			&i.OrganizationID,
			&i.CollectorName,
			&i.InstanceNum,
			&i.Bucket,
			&i.ObjectID,
			&i.Signal,
			&i.Tries,
			&i.ClaimedBy,
			&i.ClaimedAt,
			&i.HeartbeatedAt,
			&i.FileSize,
			&i.EligibleAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const inqueuePickHead = `-- name: InqueuePickHead :one
SELECT id, organization_id, instance_num, signal, file_size, queue_ts, priority
FROM public.inqueue
WHERE claimed_at IS NULL
  AND signal = $1::text
  AND eligible_at <= now()
ORDER BY priority ASC, queue_ts ASC, id ASC
LIMIT 1
FOR UPDATE
`

type InqueuePickHeadRow struct {
	ID             uuid.UUID `json:"id"`
	OrganizationID uuid.UUID `json:"organization_id"`
	InstanceNum    int16     `json:"instance_num"`
	Signal         string    `json:"signal"`
	FileSize       int64     `json:"file_size"`
	QueueTs        time.Time `json:"queue_ts"`
	Priority       int32     `json:"priority"`
}

// Pick the oldest eligible item for a given signal
func (q *Queries) InqueuePickHead(ctx context.Context, dollar_1 string) (InqueuePickHeadRow, error) {
	row := q.db.QueryRow(ctx, inqueuePickHead, dollar_1)
	var i InqueuePickHeadRow
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.InstanceNum,
		&i.Signal,
		&i.FileSize,
		&i.QueueTs,
		&i.Priority,
	)
	return i, err
}
