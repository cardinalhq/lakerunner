// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: inqueue.sql

package lrdb

import (
	"context"

	"github.com/google/uuid"
)

const claimInqueueWork = `-- name: ClaimInqueueWork :one
UPDATE inqueue AS i
SET
  claimed_by = $1,
  claimed_at = NOW()
WHERE i.id = (
  SELECT ii.id
  FROM inqueue ii
  WHERE ii.claimed_at IS NULL
    AND ii.telemetry_type = $2
  ORDER BY ii.priority DESC, ii.queue_ts
  LIMIT 1
  FOR UPDATE SKIP LOCKED
)
RETURNING id, queue_ts, priority, organization_id, collector_name, instance_num, bucket, object_id, telemetry_type, tries, claimed_by, claimed_at
`

type ClaimInqueueWorkParams struct {
	ClaimedBy     int64  `json:"claimed_by"`
	TelemetryType string `json:"telemetry_type"`
}

func (q *Queries) ClaimInqueueWork(ctx context.Context, arg ClaimInqueueWorkParams) (Inqueue, error) {
	row := q.db.QueryRow(ctx, claimInqueueWork, arg.ClaimedBy, arg.TelemetryType)
	var i Inqueue
	err := row.Scan(
		&i.ID,
		&i.QueueTs,
		&i.Priority,
		&i.OrganizationID,
		&i.CollectorName,
		&i.InstanceNum,
		&i.Bucket,
		&i.ObjectID,
		&i.TelemetryType,
		&i.Tries,
		&i.ClaimedBy,
		&i.ClaimedAt,
	)
	return i, err
}

const cleanupInqueueWork = `-- name: CleanupInqueueWork :exec
UPDATE inqueue
SET claimed_by = -1, claimed_at = NULL
WHERE claimed_at IS NOT NULL
  AND claimed_at < NOW() - INTERVAL '5 minutes'
`

func (q *Queries) CleanupInqueueWork(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupInqueueWork)
	return err
}

const deleteInqueueWork = `-- name: DeleteInqueueWork :exec
DELETE FROM inqueue
WHERE
  id = $1
  AND claimed_by = $2
`

type DeleteInqueueWorkParams struct {
	ID        uuid.UUID `json:"id"`
	ClaimedBy int64     `json:"claimed_by"`
}

func (q *Queries) DeleteInqueueWork(ctx context.Context, arg DeleteInqueueWorkParams) error {
	_, err := q.db.Exec(ctx, deleteInqueueWork, arg.ID, arg.ClaimedBy)
	return err
}

const inqueueSummary = `-- name: InqueueSummary :many
SELECT count(*) AS count, telemetry_type
FROM inqueue
WHERE claimed_at IS NULL
GROUP BY telemetry_type
ORDER BY telemetry_type
`

type InqueueSummaryRow struct {
	Count         int64  `json:"count"`
	TelemetryType string `json:"telemetry_type"`
}

func (q *Queries) InqueueSummary(ctx context.Context) ([]InqueueSummaryRow, error) {
	rows, err := q.db.Query(ctx, inqueueSummary)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InqueueSummaryRow
	for rows.Next() {
		var i InqueueSummaryRow
		if err := rows.Scan(&i.Count, &i.TelemetryType); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const putInqueueWork = `-- name: PutInqueueWork :exec
INSERT INTO inqueue (organization_id, collector_name, instance_num, bucket, object_id, telemetry_type, priority)
VALUES ($1, 'default', 9999, $2, $3, $4, $5)
`

type PutInqueueWorkParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Bucket         string    `json:"bucket"`
	ObjectID       string    `json:"object_id"`
	TelemetryType  string    `json:"telemetry_type"`
	Priority       int32     `json:"priority"`
}

func (q *Queries) PutInqueueWork(ctx context.Context, arg PutInqueueWorkParams) error {
	_, err := q.db.Exec(ctx, putInqueueWork,
		arg.OrganizationID,
		arg.Bucket,
		arg.ObjectID,
		arg.TelemetryType,
		arg.Priority,
	)
	return err
}

const releaseInqueueWork = `-- name: ReleaseInqueueWork :exec
UPDATE inqueue
SET
  claimed_by = -1,
  claimed_at = NULL,
  queue_ts = NOW() + INTERVAL '5 second',
  tries = tries + 1
WHERE
  id = $1
  AND claimed_by = $2
`

type ReleaseInqueueWorkParams struct {
	ID        uuid.UUID `json:"id"`
	ClaimedBy int64     `json:"claimed_by"`
}

func (q *Queries) ReleaseInqueueWork(ctx context.Context, arg ReleaseInqueueWorkParams) error {
	_, err := q.db.Exec(ctx, releaseInqueueWork, arg.ID, arg.ClaimedBy)
	return err
}

const touchInqueueWork = `-- name: TouchInqueueWork :exec
UPDATE inqueue
SET
  claimed_at = NOW()
WHERE
  id IN ($1::uuid[])
  AND claimed_by = $2
`

type TouchInqueueWorkParams struct {
	Ids       []uuid.UUID `json:"ids"`
	ClaimedBy int64       `json:"claimed_by"`
}

func (q *Queries) TouchInqueueWork(ctx context.Context, arg TouchInqueueWorkParams) error {
	_, err := q.db.Exec(ctx, touchInqueueWork, arg.Ids, arg.ClaimedBy)
	return err
}
