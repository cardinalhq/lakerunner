// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: batch.go

package lrdb

import (
	"context"
	"errors"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
)

var (
	ErrBatchAlreadyClosed = errors.New("batch already closed")
)

const batchDeleteMetricSegs = `-- name: BatchDeleteMetricSegs :batchexec
DELETE FROM public.metric_seg
 WHERE organization_id = $1
   AND dateint         = $2
   AND frequency_ms    = $3
   AND segment_id      = $4
   AND instance_num    = $5
`

type BatchDeleteMetricSegsBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type BatchDeleteMetricSegsParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	FrequencyMs    int32     `json:"frequency_ms"`
	SegmentID      int64     `json:"segment_id"`
	InstanceNum    int16     `json:"instance_num"`
}

func (q *Queries) BatchDeleteMetricSegs(ctx context.Context, arg []BatchDeleteMetricSegsParams) *BatchDeleteMetricSegsBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.OrganizationID,
			a.Dateint,
			a.FrequencyMs,
			a.SegmentID,
			a.InstanceNum,
		}
		batch.Queue(batchDeleteMetricSegs, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &BatchDeleteMetricSegsBatchResults{br, len(arg), false}
}

func (b *BatchDeleteMetricSegsBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *BatchDeleteMetricSegsBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const batchMarkMetricSegsRolledup = `-- name: BatchMarkMetricSegsRolledup :batchexec
UPDATE public.metric_seg
   SET rolledup = true
 WHERE organization_id = $1
   AND dateint         = $2
   AND frequency_ms    = $3
   AND segment_id      = $4
   AND instance_num    = $5
`

type BatchMarkMetricSegsRolledupBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type BatchMarkMetricSegsRolledupParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	FrequencyMs    int32     `json:"frequency_ms"`
	SegmentID      int64     `json:"segment_id"`
	InstanceNum    int16     `json:"instance_num"`
}

func (q *Queries) BatchMarkMetricSegsRolledup(ctx context.Context, arg []BatchMarkMetricSegsRolledupParams) *BatchMarkMetricSegsRolledupBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.OrganizationID,
			a.Dateint,
			a.FrequencyMs,
			a.SegmentID,
			a.InstanceNum,
		}
		batch.Queue(batchMarkMetricSegsRolledup, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &BatchMarkMetricSegsRolledupBatchResults{br, len(arg), false}
}

func (b *BatchMarkMetricSegsRolledupBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *BatchMarkMetricSegsRolledupBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const logSegmentCleanupBatchDelete = `-- name: LogSegmentCleanupBatchDelete :batchexec
DELETE FROM log_seg
WHERE organization_id = $1
  AND dateint = $2
  AND segment_id = $3
  AND instance_num = $4
`

type LogSegmentCleanupBatchDeleteBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type LogSegmentCleanupBatchDeleteParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	SegmentID      int64     `json:"segment_id"`
	InstanceNum    int16     `json:"instance_num"`
}

func (q *Queries) LogSegmentCleanupBatchDelete(ctx context.Context, arg []LogSegmentCleanupBatchDeleteParams) *LogSegmentCleanupBatchDeleteBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.OrganizationID,
			a.Dateint,
			a.SegmentID,
			a.InstanceNum,
		}
		batch.Queue(logSegmentCleanupBatchDelete, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &LogSegmentCleanupBatchDeleteBatchResults{br, len(arg), false}
}

func (b *LogSegmentCleanupBatchDeleteBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *LogSegmentCleanupBatchDeleteBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const metricSegmentCleanupBatchDelete = `-- name: MetricSegmentCleanupBatchDelete :batchexec
DELETE FROM metric_seg
WHERE organization_id = $1
  AND dateint = $2
  AND frequency_ms = $3
  AND segment_id = $4
  AND instance_num = $5
`

type MetricSegmentCleanupBatchDeleteBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type MetricSegmentCleanupBatchDeleteParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	FrequencyMs    int32     `json:"frequency_ms"`
	SegmentID      int64     `json:"segment_id"`
	InstanceNum    int16     `json:"instance_num"`
}

func (q *Queries) MetricSegmentCleanupBatchDelete(ctx context.Context, arg []MetricSegmentCleanupBatchDeleteParams) *MetricSegmentCleanupBatchDeleteBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.OrganizationID,
			a.Dateint,
			a.FrequencyMs,
			a.SegmentID,
			a.InstanceNum,
		}
		batch.Queue(metricSegmentCleanupBatchDelete, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &MetricSegmentCleanupBatchDeleteBatchResults{br, len(arg), false}
}

func (b *MetricSegmentCleanupBatchDeleteBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *MetricSegmentCleanupBatchDeleteBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const traceSegmentCleanupBatchDelete = `-- name: TraceSegmentCleanupBatchDelete :batchexec
DELETE FROM trace_seg
WHERE organization_id = $1
  AND dateint = $2
  AND segment_id = $3
  AND instance_num = $4
`

type TraceSegmentCleanupBatchDeleteBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type TraceSegmentCleanupBatchDeleteParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	SegmentID      int64     `json:"segment_id"`
	InstanceNum    int16     `json:"instance_num"`
}

func (q *Queries) TraceSegmentCleanupBatchDelete(ctx context.Context, arg []TraceSegmentCleanupBatchDeleteParams) *TraceSegmentCleanupBatchDeleteBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.OrganizationID,
			a.Dateint,
			a.SegmentID,
			a.InstanceNum,
		}
		batch.Queue(traceSegmentCleanupBatchDelete, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &TraceSegmentCleanupBatchDeleteBatchResults{br, len(arg), false}
}

func (b *TraceSegmentCleanupBatchDeleteBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *TraceSegmentCleanupBatchDeleteBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const batchInsertLogSegsDirect = `-- name: batchInsertLogSegsDirect :batchexec
INSERT INTO log_seg (
  organization_id,
  dateint,
  segment_id,
  instance_num,
  ts_range,
  record_count,
  file_size,
  created_by,
  fingerprints,
  published,
  compacted,
  label_name_map,
  stream_ids,
  stream_id_field,
  sort_version,
  agg_fields
)
VALUES (
  $1,
  $2,
  $3,
  $4,
  int8range($5, $6, '[)'),
  $7,
  $8,
  $9,
  $10::bigint[],
  $11,
  $12,
  $13,
  $14::text[],
  $15,
  $16,
  $17::text[]
)
`

type batchInsertLogSegsDirectBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type batchInsertLogSegsDirectParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	SegmentID      int64     `json:"segment_id"`
	InstanceNum    int16     `json:"instance_num"`
	StartTs        int64     `json:"start_ts"`
	EndTs          int64     `json:"end_ts"`
	RecordCount    int64     `json:"record_count"`
	FileSize       int64     `json:"file_size"`
	CreatedBy      CreatedBy `json:"created_by"`
	Fingerprints   []int64   `json:"fingerprints"`
	Published      bool      `json:"published"`
	Compacted      bool      `json:"compacted"`
	LabelNameMap   []byte    `json:"label_name_map"`
	StreamIds      []string  `json:"stream_ids"`
	StreamIDField  *string   `json:"stream_id_field"`
	SortVersion    int16     `json:"sort_version"`
	AggFields      []string  `json:"agg_fields"`
}

func (q *Queries) batchInsertLogSegsDirect(ctx context.Context, arg []batchInsertLogSegsDirectParams) *batchInsertLogSegsDirectBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.OrganizationID,
			a.Dateint,
			a.SegmentID,
			a.InstanceNum,
			a.StartTs,
			a.EndTs,
			a.RecordCount,
			a.FileSize,
			a.CreatedBy,
			a.Fingerprints,
			a.Published,
			a.Compacted,
			a.LabelNameMap,
			a.StreamIds,
			a.StreamIDField,
			a.SortVersion,
			a.AggFields,
		}
		batch.Queue(batchInsertLogSegsDirect, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &batchInsertLogSegsDirectBatchResults{br, len(arg), false}
}

func (b *batchInsertLogSegsDirectBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *batchInsertLogSegsDirectBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const batchInsertTraceSegsDirect = `-- name: batchInsertTraceSegsDirect :batchexec
INSERT INTO trace_seg (
  organization_id,
  dateint,
  segment_id,
  instance_num,
  ts_range,
  record_count,
  file_size,
  created_by,
  fingerprints,
  published,
  compacted,
  label_name_map
)
VALUES (
  $1,
  $2,
  $3,
  $4,
  int8range($5, $6, '[)'),
  $7,
  $8,
  $9,
  $10::bigint[],
  $11,
  $12,
  $13
)
`

type batchInsertTraceSegsDirectBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type batchInsertTraceSegsDirectParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	SegmentID      int64     `json:"segment_id"`
	InstanceNum    int16     `json:"instance_num"`
	StartTs        int64     `json:"start_ts"`
	EndTs          int64     `json:"end_ts"`
	RecordCount    int64     `json:"record_count"`
	FileSize       int64     `json:"file_size"`
	CreatedBy      CreatedBy `json:"created_by"`
	Fingerprints   []int64   `json:"fingerprints"`
	Published      bool      `json:"published"`
	Compacted      bool      `json:"compacted"`
	LabelNameMap   []byte    `json:"label_name_map"`
}

func (q *Queries) batchInsertTraceSegsDirect(ctx context.Context, arg []batchInsertTraceSegsDirectParams) *batchInsertTraceSegsDirectBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.OrganizationID,
			a.Dateint,
			a.SegmentID,
			a.InstanceNum,
			a.StartTs,
			a.EndTs,
			a.RecordCount,
			a.FileSize,
			a.CreatedBy,
			a.Fingerprints,
			a.Published,
			a.Compacted,
			a.LabelNameMap,
		}
		batch.Queue(batchInsertTraceSegsDirect, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &batchInsertTraceSegsDirectBatchResults{br, len(arg), false}
}

func (b *batchInsertTraceSegsDirectBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *batchInsertTraceSegsDirectBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const insertMetricSegsDirect = `-- name: insertMetricSegsDirect :batchexec
INSERT INTO metric_seg (
  organization_id,
  dateint,
  frequency_ms,
  segment_id,
  instance_num,
  ts_range,
  record_count,
  file_size,
  published,
  created_by,
  rolledup,
  fingerprints,
  sort_version,
  compacted,
  label_name_map,
  metric_names,
  metric_types
)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  int8range($6, $7, '[)'),
  $8,
  $9,
  $10,
  $11,
  $12,
  $13::bigint[],
  $14,
  $15,
  $16,
  $17::text[],
  $18::smallint[]
)
ON CONFLICT (organization_id, dateint, frequency_ms, segment_id, instance_num)
DO NOTHING
`

type insertMetricSegsDirectBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type InsertMetricSegsParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	FrequencyMs    int32     `json:"frequency_ms"`
	SegmentID      int64     `json:"segment_id"`
	InstanceNum    int16     `json:"instance_num"`
	StartTs        int64     `json:"start_ts"`
	EndTs          int64     `json:"end_ts"`
	RecordCount    int64     `json:"record_count"`
	FileSize       int64     `json:"file_size"`
	Published      bool      `json:"published"`
	CreatedBy      CreatedBy `json:"created_by"`
	Rolledup       bool      `json:"rolledup"`
	Fingerprints   []int64   `json:"fingerprints"`
	SortVersion    int16     `json:"sort_version"`
	Compacted      bool      `json:"compacted"`
	LabelNameMap   []byte    `json:"label_name_map"`
	MetricNames    []string  `json:"metric_names"`
	MetricTypes    []int16   `json:"metric_types"`
}

func (q *Queries) insertMetricSegsDirect(ctx context.Context, arg []InsertMetricSegsParams) *insertMetricSegsDirectBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.OrganizationID,
			a.Dateint,
			a.FrequencyMs,
			a.SegmentID,
			a.InstanceNum,
			a.StartTs,
			a.EndTs,
			a.RecordCount,
			a.FileSize,
			a.Published,
			a.CreatedBy,
			a.Rolledup,
			a.Fingerprints,
			a.SortVersion,
			a.Compacted,
			a.LabelNameMap,
			a.MetricNames,
			a.MetricTypes,
		}
		batch.Queue(insertMetricSegsDirect, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &insertMetricSegsDirectBatchResults{br, len(arg), false}
}

func (b *insertMetricSegsDirectBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *insertMetricSegsDirectBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}
