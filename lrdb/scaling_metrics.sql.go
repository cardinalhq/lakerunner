// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: scaling_metrics.sql

package lrdb

import (
	"context"
)

const inqueueScalingDepth = `-- name: InqueueScalingDepth :one
SELECT COALESCE(COUNT(*), 0) AS count
FROM inqueue 
WHERE telemetry_type = $1 
  AND claimed_at IS NULL
`

// Get queue depth for ingest scaling by telemetry type
func (q *Queries) InqueueScalingDepth(ctx context.Context, telemetryType string) (interface{}, error) {
	row := q.db.QueryRow(ctx, inqueueScalingDepth, telemetryType)
	var count interface{}
	err := row.Scan(&count)
	return count, err
}

const workQueueScalingDepth = `-- name: WorkQueueScalingDepth :one
SELECT COALESCE(COUNT(*), 0) AS count
FROM work_queue 
WHERE needs_run = true 
  AND runnable_at <= now() 
  AND signal = $1 
  AND action = $2
`

type WorkQueueScalingDepthParams struct {
	Signal SignalEnum `json:"signal"`
	Action ActionEnum `json:"action"`
}

// Get queue depth for work queue scaling by signal and action
func (q *Queries) WorkQueueScalingDepth(ctx context.Context, arg WorkQueueScalingDepthParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, workQueueScalingDepth, arg.Signal, arg.Action)
	var count interface{}
	err := row.Scan(&count)
	return count, err
}
