// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: scaling_metrics.sql

package lrdb

import (
	"context"
)

const metricCompactionQueueScalingDepth = `-- name: MetricCompactionQueueScalingDepth :one
SELECT COALESCE(COUNT(*), 0) AS count
FROM metric_compaction_queue
WHERE claimed_at IS NULL
`

// Get queue depth for metric compaction scaling
func (q *Queries) MetricCompactionQueueScalingDepth(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRow(ctx, metricCompactionQueueScalingDepth)
	var count interface{}
	err := row.Scan(&count)
	return count, err
}

const metricRollupQueueScalingDepth = `-- name: MetricRollupQueueScalingDepth :one
SELECT COALESCE(COUNT(*), 0) AS count
FROM metric_rollup_queue
WHERE claimed_at IS NULL
`

// Get queue depth for metric rollup scaling
func (q *Queries) MetricRollupQueueScalingDepth(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRow(ctx, metricRollupQueueScalingDepth)
	var count interface{}
	err := row.Scan(&count)
	return count, err
}

const workQueueScalingDepth = `-- name: WorkQueueScalingDepth :one
SELECT COALESCE(COUNT(*), 0) AS count
FROM work_queue
WHERE needs_run = true
  AND runnable_at <= now()
  AND signal = $1
  AND action = $2
`

type WorkQueueScalingDepthParams struct {
	Signal SignalEnum `json:"signal"`
	Action ActionEnum `json:"action"`
}

// Get queue depth for work queue scaling by signal and action
func (q *Queries) WorkQueueScalingDepth(ctx context.Context, arg WorkQueueScalingDepthParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, workQueueScalingDepth, arg.Signal, arg.Action)
	var count interface{}
	err := row.Scan(&count)
	return count, err
}
