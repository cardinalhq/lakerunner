// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: mcq.sql

package lrdb

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const mcqClaimBundle = `-- name: McqClaimBundle :exec
UPDATE public.metric_compaction_queue
SET claimed_by = $1, claimed_at = now(), heartbeated_at = now()
WHERE id = ANY($2::bigint[])
`

type McqClaimBundleParams struct {
	WorkerID int64   `json:"worker_id"`
	Ids      []int64 `json:"ids"`
}

func (q *Queries) McqClaimBundle(ctx context.Context, arg McqClaimBundleParams) error {
	_, err := q.db.Exec(ctx, mcqClaimBundle, arg.WorkerID, arg.Ids)
	return err
}

const mcqCleanupExpired = `-- name: McqCleanupExpired :many
UPDATE metric_compaction_queue
SET claimed_by = -1, claimed_at = NULL, heartbeated_at = NULL
WHERE claimed_by <> -1
  AND heartbeated_at IS NOT NULL
  AND heartbeated_at < $1
RETURNING id, queue_ts, priority, organization_id, dateint, frequency_ms, segment_id, instance_num, record_count, tries, claimed_by, claimed_at, heartbeated_at, eligible_at
`

func (q *Queries) McqCleanupExpired(ctx context.Context, cutoffTime *time.Time) ([]MetricCompactionQueue, error) {
	rows, err := q.db.Query(ctx, mcqCleanupExpired, cutoffTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MetricCompactionQueue
	for rows.Next() {
		var i MetricCompactionQueue
		if err := rows.Scan(
			&i.ID,
			&i.QueueTs,
			&i.Priority,
			&i.OrganizationID,
			&i.Dateint,
			&i.FrequencyMs,
			&i.SegmentID,
			&i.InstanceNum,
			&i.RecordCount,
			&i.Tries,
			&i.ClaimedBy,
			&i.ClaimedAt,
			&i.HeartbeatedAt,
			&i.EligibleAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mcqCompleteDelete = `-- name: McqCompleteDelete :exec
DELETE FROM public.metric_compaction_queue
WHERE claimed_by = $1
  AND id = ANY($2::bigint[])
`

type McqCompleteDeleteParams struct {
	WorkerID int64   `json:"worker_id"`
	Ids      []int64 `json:"ids"`
}

func (q *Queries) McqCompleteDelete(ctx context.Context, arg McqCompleteDeleteParams) error {
	_, err := q.db.Exec(ctx, mcqCompleteDelete, arg.WorkerID, arg.Ids)
	return err
}

const mcqDeferItems = `-- name: McqDeferItems :exec
UPDATE public.metric_compaction_queue
SET eligible_at = now() + $1::interval
WHERE claimed_by = -1
  AND id = ANY($2::bigint[])
`

type McqDeferItemsParams struct {
	Push time.Duration `json:"push"`
	Ids  []int64       `json:"ids"`
}

func (q *Queries) McqDeferItems(ctx context.Context, arg McqDeferItemsParams) error {
	_, err := q.db.Exec(ctx, mcqDeferItems, arg.Push, arg.Ids)
	return err
}

const mcqFetchCandidates = `-- name: McqFetchCandidates :many
SELECT id, organization_id, dateint, frequency_ms, instance_num, segment_id, record_count, queue_ts
FROM public.metric_compaction_queue
WHERE claimed_by = -1
  AND eligible_at <= now()
  AND organization_id = $1
  AND dateint        = $2
  AND frequency_ms   = $3
  AND instance_num   = $4
ORDER BY queue_ts ASC, id ASC
LIMIT $5
FOR UPDATE
`

type McqFetchCandidatesParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	FrequencyMs    int32     `json:"frequency_ms"`
	InstanceNum    int16     `json:"instance_num"`
	MaxRows        int32     `json:"max_rows"`
}

type McqFetchCandidatesRow struct {
	ID             int64     `json:"id"`
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	FrequencyMs    int32     `json:"frequency_ms"`
	InstanceNum    int16     `json:"instance_num"`
	SegmentID      int64     `json:"segment_id"`
	RecordCount    int64     `json:"record_count"`
	QueueTs        time.Time `json:"queue_ts"`
}

func (q *Queries) McqFetchCandidates(ctx context.Context, arg McqFetchCandidatesParams) ([]McqFetchCandidatesRow, error) {
	rows, err := q.db.Query(ctx, mcqFetchCandidates,
		arg.OrganizationID,
		arg.Dateint,
		arg.FrequencyMs,
		arg.InstanceNum,
		arg.MaxRows,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []McqFetchCandidatesRow
	for rows.Next() {
		var i McqFetchCandidatesRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Dateint,
			&i.FrequencyMs,
			&i.InstanceNum,
			&i.SegmentID,
			&i.RecordCount,
			&i.QueueTs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mcqHeartbeat = `-- name: McqHeartbeat :execrows
UPDATE public.metric_compaction_queue
SET heartbeated_at = now()
WHERE claimed_by = $1
  AND id = ANY($2::bigint[])
`

type McqHeartbeatParams struct {
	WorkerID int64   `json:"worker_id"`
	Ids      []int64 `json:"ids"`
}

func (q *Queries) McqHeartbeat(ctx context.Context, arg McqHeartbeatParams) (int64, error) {
	result, err := q.db.Exec(ctx, mcqHeartbeat, arg.WorkerID, arg.Ids)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const mcqPickHead = `-- name: McqPickHead :one
SELECT id, organization_id, dateint, frequency_ms, instance_num, segment_id, record_count, queue_ts
FROM public.metric_compaction_queue
WHERE claimed_by = -1
  AND eligible_at <= now()
ORDER BY priority ASC, eligible_at ASC, queue_ts ASC
LIMIT 1
FOR UPDATE
`

type McqPickHeadRow struct {
	ID             int64     `json:"id"`
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	FrequencyMs    int32     `json:"frequency_ms"`
	InstanceNum    int16     `json:"instance_num"`
	SegmentID      int64     `json:"segment_id"`
	RecordCount    int64     `json:"record_count"`
	QueueTs        time.Time `json:"queue_ts"`
}

func (q *Queries) McqPickHead(ctx context.Context) (McqPickHeadRow, error) {
	row := q.db.QueryRow(ctx, mcqPickHead)
	var i McqPickHeadRow
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Dateint,
		&i.FrequencyMs,
		&i.InstanceNum,
		&i.SegmentID,
		&i.RecordCount,
		&i.QueueTs,
	)
	return i, err
}

const mcqQueueWork = `-- name: McqQueueWork :exec
INSERT INTO metric_compaction_queue (
  organization_id,
  dateint,
  frequency_ms,
  segment_id,
  instance_num,
  record_count,
  priority
)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7
)
`

type McqQueueWorkParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Dateint        int32     `json:"dateint"`
	FrequencyMs    int32     `json:"frequency_ms"`
	SegmentID      int64     `json:"segment_id"`
	InstanceNum    int16     `json:"instance_num"`
	RecordCount    int64     `json:"record_count"`
	Priority       int32     `json:"priority"`
}

func (q *Queries) McqQueueWork(ctx context.Context, arg McqQueueWorkParams) error {
	_, err := q.db.Exec(ctx, mcqQueueWork,
		arg.OrganizationID,
		arg.Dateint,
		arg.FrequencyMs,
		arg.SegmentID,
		arg.InstanceNum,
		arg.RecordCount,
		arg.Priority,
	)
	return err
}

const mcqReclaimTimeouts = `-- name: McqReclaimTimeouts :execrows
WITH stale AS (
  SELECT id
  FROM public.metric_compaction_queue
  WHERE claimed_by <> -1
    AND heartbeated_at < (now() - $1::interval)
  LIMIT $2
)
UPDATE public.metric_compaction_queue AS q
SET claimed_by = -1,
    claimed_at = NULL,
    heartbeated_at = NULL,
    tries = q.tries + 1
FROM stale s
WHERE q.id = s.id
`

type McqReclaimTimeoutsParams struct {
	MaxAge  time.Duration `json:"max_age"`
	MaxRows int32         `json:"max_rows"`
}

func (q *Queries) McqReclaimTimeouts(ctx context.Context, arg McqReclaimTimeoutsParams) (int64, error) {
	result, err := q.db.Exec(ctx, mcqReclaimTimeouts, arg.MaxAge, arg.MaxRows)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const mcqRelease = `-- name: McqRelease :exec
UPDATE public.metric_compaction_queue
SET claimed_by = -1, claimed_at = NULL, heartbeated_at = NULL, tries = tries + 1
WHERE claimed_by = $1 AND id = ANY($2::bigint[])
`

type McqReleaseParams struct {
	WorkerID int64   `json:"worker_id"`
	Ids      []int64 `json:"ids"`
}

func (q *Queries) McqRelease(ctx context.Context, arg McqReleaseParams) error {
	_, err := q.db.Exec(ctx, mcqRelease, arg.WorkerID, arg.Ids)
	return err
}
