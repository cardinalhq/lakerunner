// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: bucket_management.sql

package configdb

import (
	"context"

	"github.com/google/uuid"
)

const checkOrgBucketAccess = `-- name: CheckOrgBucketAccess :one
SELECT COUNT(*) > 0 as has_access
FROM organization_buckets ob
JOIN bucket_configurations bc ON ob.bucket_id = bc.id
WHERE ob.organization_id = $1 AND bc.bucket_name = $2
`

type CheckOrgBucketAccessParams struct {
	OrgID      uuid.UUID `json:"org_id"`
	BucketName string    `json:"bucket_name"`
}

func (q *Queries) CheckOrgBucketAccess(ctx context.Context, arg CheckOrgBucketAccessParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkOrgBucketAccess, arg.OrgID, arg.BucketName)
	var has_access bool
	err := row.Scan(&has_access)
	return has_access, err
}

const createBucketConfiguration = `-- name: CreateBucketConfiguration :one
INSERT INTO bucket_configurations (
  bucket_name, cloud_provider, region, endpoint, role
) VALUES (
  $1, $2, $3, $4, $5
) RETURNING id, bucket_name, cloud_provider, region, endpoint, role
`

type CreateBucketConfigurationParams struct {
	BucketName    string  `json:"bucket_name"`
	CloudProvider string  `json:"cloud_provider"`
	Region        string  `json:"region"`
	Endpoint      *string `json:"endpoint"`
	Role          *string `json:"role"`
}

func (q *Queries) CreateBucketConfiguration(ctx context.Context, arg CreateBucketConfigurationParams) (BucketConfiguration, error) {
	row := q.db.QueryRow(ctx, createBucketConfiguration,
		arg.BucketName,
		arg.CloudProvider,
		arg.Region,
		arg.Endpoint,
		arg.Role,
	)
	var i BucketConfiguration
	err := row.Scan(
		&i.ID,
		&i.BucketName,
		&i.CloudProvider,
		&i.Region,
		&i.Endpoint,
		&i.Role,
	)
	return i, err
}

const createBucketPrefixMapping = `-- name: CreateBucketPrefixMapping :one
INSERT INTO bucket_prefix_mappings (
  bucket_id, organization_id, path_prefix, signal
) VALUES (
  $1, $2, $3, $4
) RETURNING id, bucket_id, organization_id, path_prefix, signal
`

type CreateBucketPrefixMappingParams struct {
	BucketID       uuid.UUID `json:"bucket_id"`
	OrganizationID uuid.UUID `json:"organization_id"`
	PathPrefix     string    `json:"path_prefix"`
	Signal         string    `json:"signal"`
}

func (q *Queries) CreateBucketPrefixMapping(ctx context.Context, arg CreateBucketPrefixMappingParams) (BucketPrefixMapping, error) {
	row := q.db.QueryRow(ctx, createBucketPrefixMapping,
		arg.BucketID,
		arg.OrganizationID,
		arg.PathPrefix,
		arg.Signal,
	)
	var i BucketPrefixMapping
	err := row.Scan(
		&i.ID,
		&i.BucketID,
		&i.OrganizationID,
		&i.PathPrefix,
		&i.Signal,
	)
	return i, err
}

const createOrganizationBucket = `-- name: CreateOrganizationBucket :one
INSERT INTO organization_buckets (
  organization_id, bucket_id
) VALUES (
  $1, $2
) RETURNING id, organization_id, bucket_id
`

type CreateOrganizationBucketParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	BucketID       uuid.UUID `json:"bucket_id"`
}

func (q *Queries) CreateOrganizationBucket(ctx context.Context, arg CreateOrganizationBucketParams) (OrganizationBucket, error) {
	row := q.db.QueryRow(ctx, createOrganizationBucket, arg.OrganizationID, arg.BucketID)
	var i OrganizationBucket
	err := row.Scan(&i.ID, &i.OrganizationID, &i.BucketID)
	return i, err
}

const getBucketConfiguration = `-- name: GetBucketConfiguration :one
SELECT id, bucket_name, cloud_provider, region, endpoint, role FROM bucket_configurations WHERE bucket_name = $1
`

func (q *Queries) GetBucketConfiguration(ctx context.Context, bucketName string) (BucketConfiguration, error) {
	row := q.db.QueryRow(ctx, getBucketConfiguration, bucketName)
	var i BucketConfiguration
	err := row.Scan(
		&i.ID,
		&i.BucketName,
		&i.CloudProvider,
		&i.Region,
		&i.Endpoint,
		&i.Role,
	)
	return i, err
}

const getLongestPrefixMatch = `-- name: GetLongestPrefixMatch :one
SELECT bpm.organization_id
FROM bucket_prefix_mappings bpm
JOIN bucket_configurations bc ON bpm.bucket_id = bc.id
WHERE bc.bucket_name = $1 
  AND bpm.signal = $2
  AND $3 LIKE bpm.path_prefix || '%'
ORDER BY LENGTH(bpm.path_prefix) DESC
LIMIT 1
`

type GetLongestPrefixMatchParams struct {
	BucketName string `json:"bucket_name"`
	Signal     string `json:"signal"`
	ObjectPath string `json:"object_path"`
}

func (q *Queries) GetLongestPrefixMatch(ctx context.Context, arg GetLongestPrefixMatchParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getLongestPrefixMatch, arg.BucketName, arg.Signal, arg.ObjectPath)
	var organization_id uuid.UUID
	err := row.Scan(&organization_id)
	return organization_id, err
}

const getOrganizationsByBucket = `-- name: GetOrganizationsByBucket :many
SELECT ob.organization_id 
FROM organization_buckets ob
JOIN bucket_configurations bc ON ob.bucket_id = bc.id
WHERE bc.bucket_name = $1
`

func (q *Queries) GetOrganizationsByBucket(ctx context.Context, bucketName string) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, getOrganizationsByBucket, bucketName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var organization_id uuid.UUID
		if err := rows.Scan(&organization_id); err != nil {
			return nil, err
		}
		items = append(items, organization_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
