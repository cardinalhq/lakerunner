// Copyright (C) 2025-2026 CardinalHQ, Inc
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, version 3.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

package metricsprocessing

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"slices"
	"testing"

	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/cardinalhq/lakerunner/internal/duckdbx"
)

// TestTraceFingerprintRustGoComparison compares fingerprints generated by Rust
// extension with those computed by Go. They should produce identical values.
func TestTraceFingerprintRustGoComparison(t *testing.T) {
	testFile := filepath.Join("..", "..", "testdata", "traces", "otel-traces.binpb.gz")
	if _, err := os.Stat(testFile); os.IsNotExist(err) {
		t.Skipf("Test file does not exist: %s", testFile)
	}

	ctx := context.Background()
	tmpDir := t.TempDir()
	orgID := uuid.MustParse("12340000-0000-4000-8000-000000000001").String()

	// Copy test file to temp dir
	testData, err := os.ReadFile(testFile)
	require.NoError(t, err)
	segmentFile := filepath.Join(tmpDir, "segment.binpb.gz")
	require.NoError(t, os.WriteFile(segmentFile, testData, 0644))

	// Create DuckDB connection and load extension
	db, err := duckdbx.NewDB()
	require.NoError(t, err)
	defer func() { _ = db.Close() }()

	conn, release, err := db.GetConnection(ctx)
	require.NoError(t, err)
	defer release()

	err = duckdbx.LoadOtelBinpbExtension(ctx, conn)
	require.NoError(t, err)

	// Query traces and get fingerprints from Rust extension
	query := fmt.Sprintf(`
		SELECT chq_fingerprint, span_trace_id, resource_service_name
		FROM otel_traces_read('%s', customer_id='%s')
		LIMIT 10
	`, segmentFile, orgID)

	rows, err := conn.QueryContext(ctx, query)
	require.NoError(t, err)
	defer func() { _ = rows.Close() }()

	type spanFingerprint struct {
		Fingerprints []int64
		TraceID      string
		ServiceName  string
	}

	var rustFingerprints []spanFingerprint

	for rows.Next() {
		var fpJSON, traceID string
		var serviceName *string

		err := rows.Scan(&fpJSON, &traceID, &serviceName)
		require.NoError(t, err)

		// Parse JSON array of fingerprints
		var fps []int64
		err = json.Unmarshal([]byte(fpJSON), &fps)
		require.NoError(t, err, "Failed to parse fingerprint JSON: %s", fpJSON)

		svcName := ""
		if serviceName != nil {
			svcName = *serviceName
		}

		rustFingerprints = append(rustFingerprints, spanFingerprint{
			Fingerprints: fps,
			TraceID:      traceID,
			ServiceName:  svcName,
		})
	}
	require.NoError(t, rows.Err())

	t.Logf("Retrieved %d spans with fingerprints from Rust extension", len(rustFingerprints))
	require.Greater(t, len(rustFingerprints), 0, "Should have at least one span")

	// Verify fingerprints are non-empty and sorted
	for i, sf := range rustFingerprints {
		assert.Greater(t, len(sf.Fingerprints), 0, "Span %d should have fingerprints", i)

		// Verify fingerprints are sorted (Rust should return sorted)
		sortedFps := make([]int64, len(sf.Fingerprints))
		copy(sortedFps, sf.Fingerprints)
		slices.Sort(sortedFps)
		assert.Equal(t, sortedFps, sf.Fingerprints, "Fingerprints should be sorted")

		// Log first few for inspection
		if i < 3 {
			t.Logf("Span %d: trace_id=%s, service=%s, fingerprints=%d values",
				i, sf.TraceID, sf.ServiceName, len(sf.Fingerprints))
		}
	}
}

// TestTraceFingerprintConsistency verifies that the same input produces the same
// fingerprints across multiple runs.
func TestTraceFingerprintConsistency(t *testing.T) {
	testFile := filepath.Join("..", "..", "testdata", "traces", "otel-traces.binpb.gz")
	if _, err := os.Stat(testFile); os.IsNotExist(err) {
		t.Skipf("Test file does not exist: %s", testFile)
	}

	ctx := context.Background()
	tmpDir := t.TempDir()
	orgID := uuid.MustParse("12340000-0000-4000-8000-000000000001").String()

	// Copy test file
	testData, err := os.ReadFile(testFile)
	require.NoError(t, err)
	segmentFile := filepath.Join(tmpDir, "segment.binpb.gz")
	require.NoError(t, os.WriteFile(segmentFile, testData, 0644))

	getFingerprints := func() []string {
		db, err := duckdbx.NewDB()
		require.NoError(t, err)
		defer func() { _ = db.Close() }()

		conn, release, err := db.GetConnection(ctx)
		require.NoError(t, err)
		defer release()

		err = duckdbx.LoadOtelBinpbExtension(ctx, conn)
		require.NoError(t, err)

		query := fmt.Sprintf(`
			SELECT chq_fingerprint
			FROM otel_traces_read('%s', customer_id='%s')
			ORDER BY span_trace_id, chq_timestamp
		`, segmentFile, orgID)

		rows, err := conn.QueryContext(ctx, query)
		require.NoError(t, err)
		defer func() { _ = rows.Close() }()

		var fingerprints []string
		for rows.Next() {
			var fp string
			require.NoError(t, rows.Scan(&fp))
			fingerprints = append(fingerprints, fp)
		}
		require.NoError(t, rows.Err())
		return fingerprints
	}

	// Run twice and compare
	fps1 := getFingerprints()
	fps2 := getFingerprints()

	require.Greater(t, len(fps1), 0, "Should have fingerprints")
	assert.Equal(t, fps1, fps2, "Fingerprints should be consistent across runs")

	t.Logf("Verified %d fingerprints are consistent across runs", len(fps1))
}
