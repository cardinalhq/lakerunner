// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: expiry.sql

package configdb

import (
	"context"

	"github.com/google/uuid"
)

const callExpirePublishedByIngestCutoff = `-- name: CallExpirePublishedByIngestCutoff :one
SELECT expire_published_by_ingest_cutoff($1::regclass, $2::uuid, $3::integer, $4::integer) AS rows_expired
`

type CallExpirePublishedByIngestCutoffParams struct {
	PartitionName  interface{} `json:"partition_name"`
	OrganizationID uuid.UUID   `json:"organization_id"`
	CutoffDateint  int32       `json:"cutoff_dateint"`
	BatchSize      int32       `json:"batch_size"`
}

func (q *Queries) CallExpirePublishedByIngestCutoff(ctx context.Context, arg CallExpirePublishedByIngestCutoffParams) (int64, error) {
	row := q.db.QueryRow(ctx, callExpirePublishedByIngestCutoff,
		arg.PartitionName,
		arg.OrganizationID,
		arg.CutoffDateint,
		arg.BatchSize,
	)
	var rows_expired int64
	err := row.Scan(&rows_expired)
	return rows_expired, err
}

const callFindOrgPartition = `-- name: CallFindOrgPartition :one
SELECT find_org_partition($1::regclass, $2::uuid)::text AS partition_name
`

type CallFindOrgPartitionParams struct {
	TableName      interface{} `json:"table_name"`
	OrganizationID uuid.UUID   `json:"organization_id"`
}

func (q *Queries) CallFindOrgPartition(ctx context.Context, arg CallFindOrgPartitionParams) (string, error) {
	row := q.db.QueryRow(ctx, callFindOrgPartition, arg.TableName, arg.OrganizationID)
	var partition_name string
	err := row.Scan(&partition_name)
	return partition_name, err
}

const getActiveOrganizations = `-- name: GetActiveOrganizations :many

SELECT id, name, enabled
FROM organizations
WHERE enabled = true
`

type GetActiveOrganizationsRow struct {
	ID      uuid.UUID `json:"id"`
	Name    string    `json:"name"`
	Enabled bool      `json:"enabled"`
}

// Copyright (C) 2025 CardinalHQ, Inc
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, version 3.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.
func (q *Queries) GetActiveOrganizations(ctx context.Context) ([]GetActiveOrganizationsRow, error) {
	rows, err := q.db.Query(ctx, getActiveOrganizations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActiveOrganizationsRow
	for rows.Next() {
		var i GetActiveOrganizationsRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Enabled); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpiryLastRun = `-- name: GetExpiryLastRun :one
SELECT
    organization_id,
    signal_type,
    last_run_at,
    created_at,
    updated_at
FROM expiry_run_tracking
WHERE organization_id = $1
  AND signal_type = $2
`

type GetExpiryLastRunParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	SignalType     string    `json:"signal_type"`
}

func (q *Queries) GetExpiryLastRun(ctx context.Context, arg GetExpiryLastRunParams) (ExpiryRunTracking, error) {
	row := q.db.QueryRow(ctx, getExpiryLastRun, arg.OrganizationID, arg.SignalType)
	var i ExpiryRunTracking
	err := row.Scan(
		&i.OrganizationID,
		&i.SignalType,
		&i.LastRunAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrganizationExpiry = `-- name: GetOrganizationExpiry :one
SELECT
    organization_id,
    signal_type,
    max_age_days,
    created_at,
    updated_at
FROM organization_signal_expiry
WHERE organization_id = $1
  AND signal_type = $2
`

type GetOrganizationExpiryParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	SignalType     string    `json:"signal_type"`
}

func (q *Queries) GetOrganizationExpiry(ctx context.Context, arg GetOrganizationExpiryParams) (OrganizationSignalExpiry, error) {
	row := q.db.QueryRow(ctx, getOrganizationExpiry, arg.OrganizationID, arg.SignalType)
	var i OrganizationSignalExpiry
	err := row.Scan(
		&i.OrganizationID,
		&i.SignalType,
		&i.MaxAgeDays,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertExpiryRunTracking = `-- name: UpsertExpiryRunTracking :exec
INSERT INTO expiry_run_tracking (
    organization_id,
    signal_type,
    last_run_at
) VALUES (
    $1, $2, NOW()
)
ON CONFLICT (organization_id, signal_type)
DO UPDATE SET
    last_run_at = NOW(),
    updated_at = NOW()
`

type UpsertExpiryRunTrackingParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	SignalType     string    `json:"signal_type"`
}

func (q *Queries) UpsertExpiryRunTracking(ctx context.Context, arg UpsertExpiryRunTrackingParams) error {
	_, err := q.db.Exec(ctx, upsertExpiryRunTracking, arg.OrganizationID, arg.SignalType)
	return err
}

const upsertOrganizationExpiry = `-- name: UpsertOrganizationExpiry :exec
INSERT INTO organization_signal_expiry (
    organization_id,
    signal_type,
    max_age_days
) VALUES (
    $1, $2, $3
)
ON CONFLICT (organization_id, signal_type)
DO UPDATE SET
    max_age_days = EXCLUDED.max_age_days,
    updated_at = NOW()
`

type UpsertOrganizationExpiryParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	SignalType     string    `json:"signal_type"`
	MaxAgeDays     int32     `json:"max_age_days"`
}

func (q *Queries) UpsertOrganizationExpiry(ctx context.Context, arg UpsertOrganizationExpiryParams) error {
	_, err := q.db.Exec(ctx, upsertOrganizationExpiry, arg.OrganizationID, arg.SignalType, arg.MaxAgeDays)
	return err
}
