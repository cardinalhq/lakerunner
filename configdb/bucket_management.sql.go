// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: bucket_management.sql

package configdb

import (
	"context"

	"github.com/google/uuid"
)

const checkOrgBucketAccess = `-- name: CheckOrgBucketAccess :one
SELECT COUNT(*) > 0 as has_access
FROM organization_buckets ob
JOIN bucket_configurations bc ON ob.bucket_id = bc.id
WHERE ob.organization_id = $1 AND bc.bucket_name = $2
`

type CheckOrgBucketAccessParams struct {
	OrgID      uuid.UUID `json:"org_id"`
	BucketName string    `json:"bucket_name"`
}

func (q *Queries) CheckOrgBucketAccess(ctx context.Context, arg CheckOrgBucketAccessParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkOrgBucketAccess, arg.OrgID, arg.BucketName)
	var has_access bool
	err := row.Scan(&has_access)
	return has_access, err
}

const clearBucketConfigurations = `-- name: ClearBucketConfigurations :exec
DELETE FROM bucket_configurations
`

func (q *Queries) ClearBucketConfigurations(ctx context.Context) error {
	_, err := q.db.Exec(ctx, clearBucketConfigurations)
	return err
}

const clearBucketPrefixMappings = `-- name: ClearBucketPrefixMappings :exec
DELETE FROM bucket_prefix_mappings
`

func (q *Queries) ClearBucketPrefixMappings(ctx context.Context) error {
	_, err := q.db.Exec(ctx, clearBucketPrefixMappings)
	return err
}

const clearOrganizationBuckets = `-- name: ClearOrganizationBuckets :exec
DELETE FROM organization_buckets
`

func (q *Queries) ClearOrganizationBuckets(ctx context.Context) error {
	_, err := q.db.Exec(ctx, clearOrganizationBuckets)
	return err
}

const createBucketConfiguration = `-- name: CreateBucketConfiguration :one
INSERT INTO bucket_configurations (
  bucket_name, cloud_provider, region, endpoint, role, use_path_style, insecure_tls
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
) RETURNING id, bucket_name, cloud_provider, region, endpoint, role, use_path_style, insecure_tls
`

type CreateBucketConfigurationParams struct {
	BucketName    string  `json:"bucket_name"`
	CloudProvider string  `json:"cloud_provider"`
	Region        string  `json:"region"`
	Endpoint      *string `json:"endpoint"`
	Role          *string `json:"role"`
	UsePathStyle  bool    `json:"use_path_style"`
	InsecureTls   bool    `json:"insecure_tls"`
}

func (q *Queries) CreateBucketConfiguration(ctx context.Context, arg CreateBucketConfigurationParams) (BucketConfiguration, error) {
	row := q.db.QueryRow(ctx, createBucketConfiguration,
		arg.BucketName,
		arg.CloudProvider,
		arg.Region,
		arg.Endpoint,
		arg.Role,
		arg.UsePathStyle,
		arg.InsecureTls,
	)
	var i BucketConfiguration
	err := row.Scan(
		&i.ID,
		&i.BucketName,
		&i.CloudProvider,
		&i.Region,
		&i.Endpoint,
		&i.Role,
		&i.UsePathStyle,
		&i.InsecureTls,
	)
	return i, err
}

const createBucketPrefixMapping = `-- name: CreateBucketPrefixMapping :one
INSERT INTO bucket_prefix_mappings (
  bucket_id, organization_id, path_prefix, signal
) VALUES (
  $1, $2, $3, $4
) RETURNING id, bucket_id, organization_id, path_prefix, signal
`

type CreateBucketPrefixMappingParams struct {
	BucketID       uuid.UUID `json:"bucket_id"`
	OrganizationID uuid.UUID `json:"organization_id"`
	PathPrefix     string    `json:"path_prefix"`
	Signal         string    `json:"signal"`
}

func (q *Queries) CreateBucketPrefixMapping(ctx context.Context, arg CreateBucketPrefixMappingParams) (BucketPrefixMapping, error) {
	row := q.db.QueryRow(ctx, createBucketPrefixMapping,
		arg.BucketID,
		arg.OrganizationID,
		arg.PathPrefix,
		arg.Signal,
	)
	var i BucketPrefixMapping
	err := row.Scan(
		&i.ID,
		&i.BucketID,
		&i.OrganizationID,
		&i.PathPrefix,
		&i.Signal,
	)
	return i, err
}

const createOrganizationBucket = `-- name: CreateOrganizationBucket :one
INSERT INTO organization_buckets (
  organization_id, bucket_id
) VALUES (
  $1, $2
) RETURNING id, organization_id, bucket_id, instance_num, collector_name
`

type CreateOrganizationBucketParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	BucketID       uuid.UUID `json:"bucket_id"`
}

func (q *Queries) CreateOrganizationBucket(ctx context.Context, arg CreateOrganizationBucketParams) (OrganizationBucket, error) {
	row := q.db.QueryRow(ctx, createOrganizationBucket, arg.OrganizationID, arg.BucketID)
	var i OrganizationBucket
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.BucketID,
		&i.InstanceNum,
		&i.CollectorName,
	)
	return i, err
}

const getAllCStorageProfilesForSync = `-- name: GetAllCStorageProfilesForSync :many

SELECT DISTINCT
  sp.bucket AS bucket_name,
  sp.cloud_provider,
  sp.region,
  sp.role,
  sp.organization_id
FROM c_storage_profiles sp
WHERE sp.organization_id IS NOT NULL
`

type GetAllCStorageProfilesForSyncRow struct {
	BucketName     string    `json:"bucket_name"`
	CloudProvider  string    `json:"cloud_provider"`
	Region         string    `json:"region"`
	Role           *string   `json:"role"`
	OrganizationID uuid.UUID `json:"organization_id"`
}

// Legacy table sync operations
func (q *Queries) GetAllCStorageProfilesForSync(ctx context.Context) ([]GetAllCStorageProfilesForSyncRow, error) {
	rows, err := q.db.Query(ctx, getAllCStorageProfilesForSync)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCStorageProfilesForSyncRow
	for rows.Next() {
		var i GetAllCStorageProfilesForSyncRow
		if err := rows.Scan(
			&i.BucketName,
			&i.CloudProvider,
			&i.Region,
			&i.Role,
			&i.OrganizationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBucketByOrganization = `-- name: GetBucketByOrganization :one
SELECT bc.bucket_name
FROM organization_buckets ob
JOIN bucket_configurations bc ON ob.bucket_id = bc.id
WHERE ob.organization_id = $1
`

func (q *Queries) GetBucketByOrganization(ctx context.Context, organizationID uuid.UUID) (string, error) {
	row := q.db.QueryRow(ctx, getBucketByOrganization, organizationID)
	var bucket_name string
	err := row.Scan(&bucket_name)
	return bucket_name, err
}

const getBucketConfiguration = `-- name: GetBucketConfiguration :one
SELECT id, bucket_name, cloud_provider, region, endpoint, role, use_path_style, insecure_tls FROM bucket_configurations WHERE bucket_name = $1
`

func (q *Queries) GetBucketConfiguration(ctx context.Context, bucketName string) (BucketConfiguration, error) {
	row := q.db.QueryRow(ctx, getBucketConfiguration, bucketName)
	var i BucketConfiguration
	err := row.Scan(
		&i.ID,
		&i.BucketName,
		&i.CloudProvider,
		&i.Region,
		&i.Endpoint,
		&i.Role,
		&i.UsePathStyle,
		&i.InsecureTls,
	)
	return i, err
}

const getDefaultOrganizationBucket = `-- name: GetDefaultOrganizationBucket :one
SELECT ob.organization_id, ob.instance_num, ob.collector_name, bc.bucket_name, bc.cloud_provider, bc.region, bc.role, bc.endpoint, bc.use_path_style, bc.insecure_tls
FROM organization_buckets ob
JOIN bucket_configurations bc ON ob.bucket_id = bc.id  
WHERE ob.organization_id = $1 
ORDER BY ob.instance_num, ob.collector_name 
LIMIT 1
`

type GetDefaultOrganizationBucketRow struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	InstanceNum    int16     `json:"instance_num"`
	CollectorName  string    `json:"collector_name"`
	BucketName     string    `json:"bucket_name"`
	CloudProvider  string    `json:"cloud_provider"`
	Region         string    `json:"region"`
	Role           *string   `json:"role"`
	Endpoint       *string   `json:"endpoint"`
	UsePathStyle   bool      `json:"use_path_style"`
	InsecureTls    bool      `json:"insecure_tls"`
}

func (q *Queries) GetDefaultOrganizationBucket(ctx context.Context, organizationID uuid.UUID) (GetDefaultOrganizationBucketRow, error) {
	row := q.db.QueryRow(ctx, getDefaultOrganizationBucket, organizationID)
	var i GetDefaultOrganizationBucketRow
	err := row.Scan(
		&i.OrganizationID,
		&i.InstanceNum,
		&i.CollectorName,
		&i.BucketName,
		&i.CloudProvider,
		&i.Region,
		&i.Role,
		&i.Endpoint,
		&i.UsePathStyle,
		&i.InsecureTls,
	)
	return i, err
}

const getLongestPrefixMatch = `-- name: GetLongestPrefixMatch :one
SELECT bpm.organization_id
FROM bucket_prefix_mappings bpm
JOIN bucket_configurations bc ON bpm.bucket_id = bc.id
WHERE bc.bucket_name = $1 
  AND bpm.signal = $2
  AND $3 LIKE bpm.path_prefix || '%'
ORDER BY LENGTH(bpm.path_prefix) DESC
LIMIT 1
`

type GetLongestPrefixMatchParams struct {
	BucketName string `json:"bucket_name"`
	Signal     string `json:"signal"`
	ObjectPath string `json:"object_path"`
}

func (q *Queries) GetLongestPrefixMatch(ctx context.Context, arg GetLongestPrefixMatchParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getLongestPrefixMatch, arg.BucketName, arg.Signal, arg.ObjectPath)
	var organization_id uuid.UUID
	err := row.Scan(&organization_id)
	return organization_id, err
}

const getOrganizationBucketByCollector = `-- name: GetOrganizationBucketByCollector :one
SELECT ob.organization_id, ob.instance_num, ob.collector_name, bc.bucket_name, bc.cloud_provider, bc.region, bc.role, bc.endpoint, bc.use_path_style, bc.insecure_tls
FROM organization_buckets ob
JOIN bucket_configurations bc ON ob.bucket_id = bc.id  
WHERE ob.organization_id = $1 AND ob.collector_name = $2
`

type GetOrganizationBucketByCollectorParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	CollectorName  string    `json:"collector_name"`
}

type GetOrganizationBucketByCollectorRow struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	InstanceNum    int16     `json:"instance_num"`
	CollectorName  string    `json:"collector_name"`
	BucketName     string    `json:"bucket_name"`
	CloudProvider  string    `json:"cloud_provider"`
	Region         string    `json:"region"`
	Role           *string   `json:"role"`
	Endpoint       *string   `json:"endpoint"`
	UsePathStyle   bool      `json:"use_path_style"`
	InsecureTls    bool      `json:"insecure_tls"`
}

func (q *Queries) GetOrganizationBucketByCollector(ctx context.Context, arg GetOrganizationBucketByCollectorParams) (GetOrganizationBucketByCollectorRow, error) {
	row := q.db.QueryRow(ctx, getOrganizationBucketByCollector, arg.OrganizationID, arg.CollectorName)
	var i GetOrganizationBucketByCollectorRow
	err := row.Scan(
		&i.OrganizationID,
		&i.InstanceNum,
		&i.CollectorName,
		&i.BucketName,
		&i.CloudProvider,
		&i.Region,
		&i.Role,
		&i.Endpoint,
		&i.UsePathStyle,
		&i.InsecureTls,
	)
	return i, err
}

const getOrganizationBucketByInstance = `-- name: GetOrganizationBucketByInstance :one
SELECT ob.organization_id, ob.instance_num, ob.collector_name, bc.bucket_name, bc.cloud_provider, bc.region, bc.role, bc.endpoint, bc.use_path_style, bc.insecure_tls
FROM organization_buckets ob
JOIN bucket_configurations bc ON ob.bucket_id = bc.id  
WHERE ob.organization_id = $1 AND ob.instance_num = $2
`

type GetOrganizationBucketByInstanceParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	InstanceNum    int16     `json:"instance_num"`
}

type GetOrganizationBucketByInstanceRow struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	InstanceNum    int16     `json:"instance_num"`
	CollectorName  string    `json:"collector_name"`
	BucketName     string    `json:"bucket_name"`
	CloudProvider  string    `json:"cloud_provider"`
	Region         string    `json:"region"`
	Role           *string   `json:"role"`
	Endpoint       *string   `json:"endpoint"`
	UsePathStyle   bool      `json:"use_path_style"`
	InsecureTls    bool      `json:"insecure_tls"`
}

func (q *Queries) GetOrganizationBucketByInstance(ctx context.Context, arg GetOrganizationBucketByInstanceParams) (GetOrganizationBucketByInstanceRow, error) {
	row := q.db.QueryRow(ctx, getOrganizationBucketByInstance, arg.OrganizationID, arg.InstanceNum)
	var i GetOrganizationBucketByInstanceRow
	err := row.Scan(
		&i.OrganizationID,
		&i.InstanceNum,
		&i.CollectorName,
		&i.BucketName,
		&i.CloudProvider,
		&i.Region,
		&i.Role,
		&i.Endpoint,
		&i.UsePathStyle,
		&i.InsecureTls,
	)
	return i, err
}

const getOrganizationsByBucket = `-- name: GetOrganizationsByBucket :many
SELECT ob.organization_id 
FROM organization_buckets ob
JOIN bucket_configurations bc ON ob.bucket_id = bc.id
WHERE bc.bucket_name = $1
`

func (q *Queries) GetOrganizationsByBucket(ctx context.Context, bucketName string) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, getOrganizationsByBucket, bucketName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var organization_id uuid.UUID
		if err := rows.Scan(&organization_id); err != nil {
			return nil, err
		}
		items = append(items, organization_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasExistingStorageProfiles = `-- name: HasExistingStorageProfiles :one
SELECT COUNT(*) > 0 as has_profiles
FROM bucket_configurations
`

func (q *Queries) HasExistingStorageProfiles(ctx context.Context) (bool, error) {
	row := q.db.QueryRow(ctx, hasExistingStorageProfiles)
	var has_profiles bool
	err := row.Scan(&has_profiles)
	return has_profiles, err
}

const upsertBucketConfiguration = `-- name: UpsertBucketConfiguration :one
INSERT INTO bucket_configurations (
  bucket_name, cloud_provider, region, endpoint, role, use_path_style, insecure_tls
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
) ON CONFLICT (bucket_name) DO UPDATE SET
  cloud_provider = EXCLUDED.cloud_provider,
  region = EXCLUDED.region,
  endpoint = EXCLUDED.endpoint,
  role = EXCLUDED.role,
  use_path_style = EXCLUDED.use_path_style,
  insecure_tls = EXCLUDED.insecure_tls
RETURNING id, bucket_name, cloud_provider, region, endpoint, role, use_path_style, insecure_tls
`

type UpsertBucketConfigurationParams struct {
	BucketName    string  `json:"bucket_name"`
	CloudProvider string  `json:"cloud_provider"`
	Region        string  `json:"region"`
	Endpoint      *string `json:"endpoint"`
	Role          *string `json:"role"`
	UsePathStyle  bool    `json:"use_path_style"`
	InsecureTls   bool    `json:"insecure_tls"`
}

func (q *Queries) UpsertBucketConfiguration(ctx context.Context, arg UpsertBucketConfigurationParams) (BucketConfiguration, error) {
	row := q.db.QueryRow(ctx, upsertBucketConfiguration,
		arg.BucketName,
		arg.CloudProvider,
		arg.Region,
		arg.Endpoint,
		arg.Role,
		arg.UsePathStyle,
		arg.InsecureTls,
	)
	var i BucketConfiguration
	err := row.Scan(
		&i.ID,
		&i.BucketName,
		&i.CloudProvider,
		&i.Region,
		&i.Endpoint,
		&i.Role,
		&i.UsePathStyle,
		&i.InsecureTls,
	)
	return i, err
}

const upsertOrganizationBucket = `-- name: UpsertOrganizationBucket :exec
INSERT INTO organization_buckets (
  organization_id, bucket_id
) VALUES (
  $1, $2
) ON CONFLICT (organization_id, bucket_id) DO NOTHING
`

type UpsertOrganizationBucketParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	BucketID       uuid.UUID `json:"bucket_id"`
}

func (q *Queries) UpsertOrganizationBucket(ctx context.Context, arg UpsertOrganizationBucketParams) error {
	_, err := q.db.Exec(ctx, upsertOrganizationBucket, arg.OrganizationID, arg.BucketID)
	return err
}
