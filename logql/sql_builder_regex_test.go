// Copyright (C) 2025 CardinalHQ, Inc
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, version 3.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

package logql

import (
	"database/sql"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	_ "github.com/marcboeker/go-duckdb/v2"
)

func TestDuckDBRegexMatching_InOperatorPattern(t *testing.T) {
	db, err := sql.Open("duckdb", "")
	require.NoError(t, err)
	defer func() { _ = db.Close() }()

	// Test the regex pattern generated by the 'in' operator with multiple values containing dots
	// This pattern is what gets generated by legacy_translator.go for the 'in' operator
	pattern := `^(example\.com-1234567890\.11_2025-10-29-170129_server-04|example\.com-1234567890\.11_2025-10-29-170129_controller|example\.com-1234567890\.11_2025-10-29-170129_server-03)$`

	tests := []struct {
		value    string
		expected bool
	}{
		{"example.com-1234567890.11_2025-10-29-170129_server-04", true},
		{"example.com-1234567890.11_2025-10-29-170129_controller", true},
		{"example.com-1234567890.11_2025-10-29-170129_server-03", true},
		{"example.com-1234567890.11_2025-10-29-170129_server-05", false},
		{"other-file", false},
	}

	for _, tt := range tests {
		t.Run(tt.value, func(t *testing.T) {
			query := "SELECT regexp_matches(?, ?) AS match_result"

			var match bool
			err := db.QueryRow(query, tt.value, pattern).Scan(&match)
			require.NoError(t, err)

			assert.Equal(t, tt.expected, match,
				"Expected regexp_matches(%q, %q) to be %v",
				tt.value, pattern, tt.expected)
		})
	}
}

func TestDuckDBRegexMatching_SingleBackslashVsDoubleBackslash(t *testing.T) {
	db, err := sql.Open("duckdb", "")
	require.NoError(t, err)
	defer func() { _ = db.Close() }()

	value := "example.com-test"

	// Test single backslash escape (should work in parameterized query)
	query := "SELECT regexp_matches(?, ?) AS match_result"

	// Single backslash in Go string literal becomes literal backslash in SQL parameter
	patternSingle := `^example\.com-test$`

	var matchSingle bool
	err = db.QueryRow(query, value, patternSingle).Scan(&matchSingle)
	require.NoError(t, err)

	assert.True(t, matchSingle, "Single backslash escape should work with parameterized query")

	// Test unescaped (dots match any character)
	patternUnescaped := `^example.com-test$`

	var matchUnescaped bool
	err = db.QueryRow(query, value, patternUnescaped).Scan(&matchUnescaped)
	require.NoError(t, err)

	assert.True(t, matchUnescaped, "Unescaped dots also match (since . matches any char)")

	// But unescaped should also match invalid values
	invalidValue := "exampleXcom-test"
	var matchInvalid bool
	err = db.QueryRow(query, invalidValue, patternUnescaped).Scan(&matchInvalid)
	require.NoError(t, err)

	assert.True(t, matchInvalid, "Unescaped dots incorrectly match 'X' instead of '.'")

	// But escaped should NOT match invalid values
	var matchInvalidEscaped bool
	err = db.QueryRow(query, invalidValue, patternSingle).Scan(&matchInvalidEscaped)
	require.NoError(t, err)

	assert.False(t, matchInvalidEscaped, "Escaped dots should NOT match 'X'")
}
